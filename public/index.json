[{"content":"``s This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.\nIn Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.\nTo communicate, containers connected to a bridge network can communicate using the container\u0026rsquo;s name as hostname. This means that, if we deploy a container by specifying the flag --name or -n, to communicate we can use the name given to the container as the URL, instead of having to use the container\u0026rsquo;s IP address in the network. Docker allows this by internally handling the DNS resolution of these names, to ensure that containers can find each other using known names and not IPs.\nThe isolation of the network is great and all but sometimes we need to access external networks, or at least, we might need to be able to access the application running inside of the container. For this we can open ports in the network by using the flag -p or --publish, and specifying the target port we want to open HOST:CONTAINER.\nHaving now understood how Bridge networks work, another problem arises. Bridge networks are limited to a single Docker Host (let\u0026rsquo;s say, our local machine). Therefore, there is no way of connecting containers deployed in serveral machines, as we normally want to do when we use Docker Swarm.\nOverlay networks solve this issue by creating a distributed network across multiple hosts (this is done using a combination of tunneling and encryption, but this is a bit hard to explain here). This creates a network where all containers attached to the network are able to communicate, even if they are running in different hosts.\nNow, due to their distributed nature, we need to find a new way to communicate. Also, with Docker Swarm, we are deploying services which can have several instances of the same application, thus complicating matters. A service in Docker is an abstraction to define how a group of containers (one or more) should run or behave. It also provides scalling, load balancing, and other things which I\u0026rsquo;ll get to in another post.\nSo, in an Overlay Network we have two methods to communicate between containers. The first is by using the IP addresses of the container we wish to target (as we already could in a bridge network). The second is to communicate using the service name. Let\u0026rsquo;s supose that we have two services, one called web-server with 3 replicas, and the other called backend-server with 2 replicas. For the web-service to communicate with the backend-service it can use something like http://backend-service:\u0026lt;PORT\u0026gt;, and the rest of the work is done by Swarm, like the load balancing between the instances of the service.\nWhen it comes to communicating between two different bridge networks, Docker doesn’t natively support cross-network communication out of the box because bridge networks are isolated from each other. However, there are ways to enable communication between containers on different bridge networks. The key approaches involve routing traffic between the networks using either:\nContainer Networking: A container connected to both bridge networks. Port Publishing and External Access: Using the host network as an intermediary. Custom Network Drivers: Using more advanced configurations like macvlan drivers. Before going through each one of the solutions, let\u0026rsquo;s have a quick chat about why you would want to enable communication between containers on different networks. After all, Docker’s network model is designed with isolation in mind, providing separate namespaces for containers to enhance security, reduce interference, and ensure predictable behavior. So, why break this isolation? Here are a few scenarios where cross-network communication might be necessary:\nMicroservices Architecture with Legacy Systems:\nMicroservices in different networks may need to connect with legacy systems. Cross-network communication enables integration while maintaining isolation.\nComplex Application Segmentation:\nSegmenting application components into different networks improves organization. Controlled communication ensures they still function together.\nEnhanced Security and Compliance:\nIsolating sensitive services in secure networks ensures compliance. Controlled interaction allows functionality without compromising security.\nMulti-Host and Hybrid Deployment:\nDistributed applications across multiple hosts or cloud/on-prem setups may need to connect. Bridging networks enables unified communication across environments.\nService Discovery Challenges:\nDifferent stages or services in isolated networks can complicate discovery. Cross-network communication ensures access to shared resources or services.\nContainer Networking Let\u0026rsquo;s start with our solution by creating two separate bridge networks. We\u0026rsquo;ll place one container on each network and use a third container that is attached to both networks as a communication channel, or \u0026ldquo;gateway.\u0026rdquo; This container will allow the two isolated networks to communicate with each other.\nMessaging Queues Messaging queues are communication mechanisms used to exchange data between services, applications, or componenets in a decouples and asynchrounous way. Think of it like a newsletter. You have a producer - someone who publishes the newsletter; a consumer - the person who receives the newsletter; and a queue - similar to the mailing list, where the newsletter is stored untill all the recipients retrieve and read it. Like with a newsletter, in a messaging queue you can have several consummers which can receive and read the messages at different times. Each subscriber (consumer) consumes the content independently. Unlike traditional newsletters, you can also have several producers to the same queue.\nAlso, unlike newletters, in a messaging queue system, consumers may acknoledge receipt of messages, and the queue may ensure that messages are delivered exactly once or at least once per consumer.\nFor this example, we\u0026rsquo;ll use RabbitMQ, but there are several commonly used messaging queues such as Apache Kafka, ActiveMQ, Mosquitto (similar, not really a messaging queue, but a message broker), and of course solutions by your favorite hyperscaler (AWS, Azure, and the like).\nStep 0: The program We\u0026rsquo;ll deploy a program that sends and receives messages on a message queue. The idea is to deploy the same program on both networks, and send messages between the networks using the message broker. In this case, the program will do this automatically.\nimport pika import time import random import os # Set up logging logging.basicConfig(level=logging.INFO) # Set up connection parameters rabbitmq_host = os.getenv(\u0026#39;RABBITMQ_HOST\u0026#39;) # RabbitMQ container name # Check if the RabbitMQ host is set if not rabbitmq_host: logging.error(\u0026#34;RABBITMQ_HOST environment variable is not set\u0026#34;) exit(1) connection_params = pika.ConnectionParameters(host=rabbitmq_host) # Function to send messages def send_message(channel, message): # Send a message back to the queue channel.basic_publish(exchange=\u0026#39;\u0026#39;, routing_key=\u0026#39;test_queue\u0026#39;, body=message) print(f\u0026#34; [x] Sent \u0026#39;{message}\u0026#39;\u0026#34;) # Function to handle received messages and send a response def on_message_received(ch, method, properties, body): received_message = body.decode() print(f\u0026#34; [x] Received \u0026#39;{received_message}\u0026#39;\u0026#34;) # Create a response message response_message = f\u0026#34;Response to \u0026#39;{received_message}\u0026#39; from {random.randint(1, 1000)}\u0026#34; # Simulate some processing time time.sleep(2) # Send the response message send_message(ch, response_message) # Function to start the auto-messaging system def start_auto_messaging(start_with_message): # Set up a connection and channel connection = pika.BlockingConnection(connection_params) channel = connection.channel() # Declare a queue channel.queue_declare(queue=\u0026#39;test_queue\u0026#39;) # Check if the system should start by sending a message if start_with_message: initial_message = f\u0026#34;Initial message from {random.randint(1, 1000)}\u0026#34; send_message(channel, initial_message) # Start consuming and handle each message with the on_message_received function channel.basic_consume(queue=\u0026#39;test_queue\u0026#39;, on_message_callback=on_message_received, auto_ack=True) print(\u0026#39; [*] Waiting for messages. To exit press CTRL+C\u0026#39;) channel.start_consuming() if __name__ == \u0026#39;__main__\u0026#39;: # Read environment variable to check if the system should start by sending a message start_with_message = os.getenv(\u0026#39;START_WITH_MESSAGE\u0026#39;, \u0026#39;false\u0026#39;).lower() == \u0026#39;true\u0026#39; # Start the auto-messaging system start_auto_messaging(start_with_message) The application is simple: the application receives two environmental variable - one to check if it should start communicating, and the other with the name of the container (in this case RabbitMQ) with the messaging queue. If the application starts communicating, then it starts by sending a message with a random integer. Then, the second container will receive and send back a messgage composed of the message received and a new random integer.\nNOTE: There\u0026rsquo;s a slight bug in the app. You\u0026rsquo;ll see that the container who sends the message is also able to read it\u0026rsquo;s own message. This can be avoided by using an app ID and setting it as a property of the message\nchannel.basic_publish(exchange=\u0026#39;\u0026#39;, routing_key=\u0026#39;test_queue\u0026#39;, body=message, properties=pika.BasicProperties( app_id=app_id )) Then you can read the message properties, and select to only process the messages where the app_id isn\u0026rsquo;t the same as the application. I\u0026rsquo;ve tried to apply this, but there is some timing issues, which leads to the both containers stopping sending messages. When I don\u0026rsquo;t check the app ID, the timing of the messages aligns, as the second container sends two messages in a row, which leads to the first container receiving a message and the ping-pong process of messages starts and continues correctly. If you have a solution for this problem, please don\u0026rsquo;t hesitate to send me a message!\nStep 1: Setup the networks To start, let\u0026rsquo;s create the bridge networks. Remember, you can always do the same thing using Docker Compose.\ndocker network create bridge-net-1 docker network create bridge-net-2 To check if the networks were correctly created, run the following command:\ndocker network ls The output should be something like:\ncode-gen ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 217ae951f2e2 bridge bridge local ece230c416f2 bridge-net-1 bridge local 34d8e1e02ae2 bridge-net-2 bridge local d068772975fd host host local 8bc70472ebe1 none null local Step 2: Deploy containers on each network Next, we\u0026rsquo;ll deploy the RabbitMQ container:\ndocker run -d --name rabbitmq --network bridge-net-1 --network bridge-net-2 rabbitmq Once RabbitMQ is deployed and running, we can deploy the same container in each of the networks:\ndocker run -d --name app1 --network bridge-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker run -d --name app2 --network bridge-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Once both containers are running, we an check on the logs that the messages are being passed correctly, even if the containers are in seperate networks. The RabbitMQ container, which is attached to both networks, is able to receive messages from both networks and passed them to the opposite network from which the message was sent.\nI\u0026rsquo;ve also wrote a docker-compose file to make the deployment of the application simpler.\nOverlay Networks While overlay networks are spread across different hosts, the same process can be used. You can create two overlay networks, attach one container to both, and use that container as a communication channel between the networks. The only difference would be on network creation, where you would have to specify the overlay type.\ndocker network create -d overlay overlay-net-1 docker network create -d overlay overlay-net-2 Now, if you attempt to create these networks you might encounter the following error:\nError response from daemon: This node is not a swarm manager. Use \u0026#34;docker swarm init\u0026#34; or \u0026#34;docker swarm join\u0026#34; to connect this node to swarm and try again. Overlay networks are Swarm-specific networks, and can only be created by the manager of the swarm.\nTo test this locally let\u0026rsquo;s create a Swarm by doing docker swarm init, create the two networks, and lauch the application as a stack of services. First, let\u0026rsquo;s deploy RabbitMQ as a service:\ndocker service create --name rabbitmq --network overlay-net-1 --network overlay-net-2 --replicas 1 rabbitmq:latest Notice that we aren\u0026rsquo;t publishing any ports, as we are not trying to access the RabbitMQ instance from outside of both networks. Without publishing ports, only the containers connected to the network can communicate with the service.\nNow, let\u0026rsquo;s deploy our services:\ndocker service create --name app1 --network overlay-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker service create --name app2 --network overlay-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Then, we can check the logs by:\ndocker service logs app1 You should be able to see messages comming and going from the RabbitMQ between the services deployed in two different overlay networks.\nPort Publishing and External Acess In certain cases, we might need to communicate with services running outside of your networks. For this, we need to publish ports for the containers that will communicate. In this case, we are opening these ports to the world—anyone that knows that the port is open can attempt to communicate with our services. This capability is essential for applications that need to be accessed by users or other systems outside of the Docker environment, such as web applications, APIs, or databases.\nHow Port Publishing works? When you publish a port, you map a port from the container to a port on the host machine. This allows traffic sent to the host\u0026rsquo;s specified port to be routed to the corresponding port on the container. For instance, if you have a web application running in a container on port 80, you can expose it to the outside world by mapping it to a port on the host, such as port 8080.\ndocker service create \\ --name my-web-app \\ --publish published=8080,target=80 \\ my-web-app-image While port publishing is a powerful feature, it also introduces security considerations:\nOpen Ports: When you expose a port, it becomes accessible to anyone who knows the host\u0026rsquo;s IP address and the port number. You should take this into consideration and employ proper security measures. Secure Protocols: Always prefer secure protocols, such as HTTPS, when exposing ports. Rate Limiting: If you are exposing a port, be sure to implement throttling mechanisms to prevent abuse of your services. Port publishing is a critical part of Docker use, even if you are using a Docker network. There are services that we wish to expose to be able to use them from wherever we are. If you want to know more about how to properly use Swarm, I\u0026rsquo;ve started a series on [Masetering Docker Swarm]({{ \u0026lt; ref \u0026ldquo;Mastering_Docker_Swarm_Pt._1\u0026rdquo;\u0026gt;}}).\nCustom Network Drivers While Bridge and Overlay networks are great out-of-the-box, there are situations where these won\u0026rsquo;t suffice. For this, Docker provides a way to build custom network drivers, which can be customized to suit specific application requirements. This allows for greater flexibility in configuring networks.\nThe reasons for the use of custom drivers might differ, one use case which seems clear is when you need support for specific, non-standard, protocols (instead of HTTP, something like multicast or specifiying MTU sizes). Another case is when we need to integrate with existing entriprise networks, and better yet, with legacy systems.\nAnother good reason might be the need for enhanced performace - let\u0026rsquo;s say for high-performance applications, where you need to process real-time data. With a custom network driver, you can tune the network paramaters, which can lead to improvements in data transfer rates or reduced latency.\nAlso, by creating a custom network driver you can incorporate advanced security features, to further enhanced isolation and encryption of your data.\nAs you can see here, there are already several network drivers developed, which could be used in you next project. These drivers add several tools on top of the default networks, from enhanced logging and monitoring capabilities to support for more complex routing policies.\nThe procedure to run a custom network driver is similar for all drivers. First, you install the driver on the host, then you create a network with the new driver, and you attach containers to that network. In some cases, you might need to configure the network by defining network policies for example.\nIn general, custom network drivers provide the flexibility to address specific network challenges in modern applications.\n","permalink":"http://localhost:1313/posts/dockernetworking/","summary":"\u003cp\u003e``s\nThis tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.\u003c/p\u003e\n\u003cp\u003eIn Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.\u003c/p\u003e","title":"Quick Docker Networking Tutorial"},{"content":"Normally, there is no reason to publish drafts. I mean, who wants to display to the world their unfinished, unpolished and unverfied work? Aparently me. The idea was borned after I read Learning in Public by Shawn Wang. The premise is simple: while the majority of us learn in private, learning by publicaly displaying what you know about a subject, and submitting yourself to the wider public critisism has the ability of actually improving how deep you learn. Because there\u0026rsquo;s always someone out there who knows more than you.\nI decided to apply the same reason to my drafts. Once I started my PhD, I\u0026rsquo;ve noticed that I write supremely badly. Better yet, I tend to drive straight to the point, to a point only understandable by me. I lack a talent in explaining things, or at least explaining myself. After noticing that this would pose a problem later on in my PhD, I decided to create this blog, and share with the anyone who has any interest in any of the subjects I\u0026rsquo;ll discuss, what I\u0026rsquo;m doing trying to explain it in more detail. The second point is that I will use this website like a notebook, as a method to further extend my knowledge. Therefore, the idea to publish drafts is to invite (constructive) criticism from anyone who might know more than me, or from those who wish to learn about the subjects that I\u0026rsquo;m wrtting and aren\u0026rsquo;t undestanding much.\nSo, if you wish to form a (polite) complaint about any of my posts, please do not hesitate to write to my email\n","permalink":"http://localhost:1313/posts/publishingdrafts/","summary":"\u003cp\u003eNormally, there is no reason to publish drafts. I mean, who wants to display to the world their unfinished, unpolished and unverfied work? Aparently me. The idea was borned after I read \u003ca href=\"https://www.swyx.io/learn-in-public\"\u003eLearning in Public\u003c/a\u003e by Shawn Wang. The premise is simple: while the majority of us learn in private, learning by publicaly displaying what you know about a subject, and submitting yourself to the wider public critisism has the ability of actually improving how \u003cem\u003edeep\u003c/em\u003e you learn. Because there\u0026rsquo;s always someone out there who knows more than you.\u003c/p\u003e","title":"Publishing Drafts"},{"content":"Python is renowned for its exceptional versatility, making it ideal for diverse applications, from web development to data science. In this blog post, we\u0026rsquo;re diving into a powerful feature known as Decorators. Although I had not explored Decorators for quite some time, I decided it was finally time to thoroughly understand and master them.\nUnderstanding Nested Functions in Python Before diving into decorators, it\u0026rsquo;s helpful to understand nested functions in Python. A nested function is defined within another function, and it can access variables from the enclosing scope. Here’s an example to illustrate this:\ndef outer(x): def inner(y): return x + y return inner adding = outer(9) # At this moment, the outer function is initialized with the argument 5. result = adding(10) # now we initilize the inner function with argument 6 print(result) # Result: 19 In the example above, inner is a nested function that adds a given number y to x, which is a parameter of the outer function outer. The nested function inner is only created and accessible within the outer function, not outside of it.\nNested functions are valuable for several reasons:\nEncapsulation: They help keep parts of code tightly coupled and hidden from the global scope. Scope Management: They can manipulate variables from their enclosing scope. Factory Functions: They can be used to create specific types of functions dynamically. Closures: They allow the inner function to remember the state of its environment, even after the outer function has finished executing. Decoding Decorators Moving from nested functions to decorators, a decorator in Python is essentially a function that takes another function and extends its behavior without permanently modifying it. This is a fundamental concept in Python, especially useful in scenarios like logging, access control, memoization, and more.\ndef my_decorator(func): def wrapper(): print(\u0026#34;Something happens before func execution\u0026#34;) func() print(\u0026#34;Something happens after func execution\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello, World!\u0026#34;) Unlike Nested Functions, Decorators are specifically built to enhance or modify the behaviour of other functions. They provide a clear, readable way to apply common functionality to multiple functions or methods, while nested functions can only serve function described within.\nProperties Decorators have certain properties that should be noted. Understanding these allows us to extract more value from using decorators.\nStacking Decorators can be stacked, meaning one function can have more than one decorator. Each decorator wraps the function return by the decorator beneath it. This is particularly useful for combining functionalities such as logging, error handling and access control in a modular way\n@decorator2 @decorator1 def some_function(): return None When stacking decorators, the decorator closest to the function definition runs first as a wrapper, but last in execution flow around the function call itself. This is beacuse each decorator wraps the result of the previous decorator.\n# [ [ [ [ # F D F D G u e u e O o n c n c r A c o c o d T t r t r e i a i a r D o t o t i n o n o o a ] r ] r f g 1 1 r ] ] E a x m e [ [ c t D D u o e [ e [ t c D c D i I o e o e o l r c r c n l a o a o : u t r t r s o a o a f t r t r t u r 1 o 1 o n a ] r ] r c t 2 2 t e : ] : ] i o S f : E : n t u x a n d e E c c e c x k t c u e e i o t c d d o r e u e n a s t c D t e o e i o f s r c s r i a o 1 r n t r w s e o a r i t x r t a s t 1 o p r p w s e r d a i p d n b p e y e c P d o y d r t e b a h c y t o o o n r d r a e 2 t c o o r r 1 a t o r 2 Parameterization Decorators can be designed to take arguments. This requires the creation of a decorator factory, which returns a decorator. This is useful when you need to customize the behavior of the decorator for different functions:\ndef repeat(number_of_times): def decorator(func): def wrapper(*args, **kwargs): for _ in range(number_of_times): result = func(*args, **kwargs) return result return wrapper return decorator @repeat(number_of_times=3) def greet(name): print(f\u0026#34;Hello {name}\u0026#34;) greet(\u0026#34;Alice\u0026#34;) Metadata Preserverance By default decorators do not keep a function\u0026rsquo;s metadata (name, docstring and annotations). This is typically achieved using functools.wraps in the decorator\u0026rsquo;s wrapper function:\nimport functools def my_decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Something is happening before the function is called.\u0026#34;) return func(*args, **kwargs) return wrapper @my_decorator def say_hello(): \u0026#34;\u0026#34;\u0026#34;Say hello function\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Hello!\u0026#34;) print(say_hello.__name__) # Outputs \u0026#39;say_hello\u0026#39; print(say_hello.__doc__) # Outputs \u0026#39;Say hello function\u0026#39; Non-Functional Decorators (Class Decorators) Decorators aren\u0026rsquo;t limited to functions; they can also be used to be applied to classes. Class decorators can modify or enhance class behavior in a similar way to function decorators:\ndef decorator(cls): class WrappedClass(cls): def new_method(self): return \u0026#34;This is a new method added by the decorator\u0026#34; return WrappedClass @decorator class OriginalClass: def original_method(self): return \u0026#34;This method is part of the original class\u0026#34; obj = OriginalClass() print(obj.new_method()) # Outputs: This is a new method added by the decorator Usage Function Decorators Decorators should be used when there is several functions that need to share common functionality, avoiding code duplication. For example, a great use case is logging and debugging the execution of a program. Decorators can be used to log entry, exit and various states of function execution without cluttering the actual business logic with logging code.\ndef log_execution(func): def wrapper(*args, **kwargs): print(f\u0026#34;Entering {func.__name__}...\u0026#34;) result = func(*args, **kwargs) print(f\u0026#34;Exiting {func.__name__}...\u0026#34;) print(f\u0026#34;Execution status: {result}\u0026#34;) return result return wrapper @log_execution def my_function(): # function code here pass Decorators as Performance Measurment Another use case is the usage of Decorators as performance measurement. A decorator can be developed to add timing code that records how long a functions takes to run.\nimport time def measure_time(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() execution_time = end_time - start_time print(f\u0026#34;Function {func.__name__} took {execution_time} seconds to run.\u0026#34;) return result return wrapper @measure_time def my_function(): # function code here pass Decorators for Access Control Certain function will require a finer access control and authentication policies. A decorator can be used to add this to certain function, ensuring that only authorized users are able to execute ceratin functionalities. This is common in web frameworks where ceratin routes or actions are restricted to logged-in users or users with specific roles.\n# Simulating a user database and session users = { \u0026#39;alice\u0026#39;: \u0026#39;password123\u0026#39;, \u0026#39;bob\u0026#39;: \u0026#39;securepassword\u0026#39; } current_user = None def login(username, password): \u0026#34;\u0026#34;\u0026#34; Simulate user login, setting the current user if successful. \u0026#34;\u0026#34;\u0026#34; global current_user if username in users and users[username] == password: current_user = username print(f\u0026#34;{username} has logged in successfully.\u0026#34;) return True print(\u0026#34;Failed login attempt.\u0026#34;) return False def logout(): \u0026#34;\u0026#34;\u0026#34; Log out the current user \u0026#34;\u0026#34;\u0026#34; global current_user current_user = None print(\u0026#34;User has been logged out.\u0026#34;) def is_logged_in(): \u0026#34;\u0026#34;\u0026#34; Check if there\u0026#39;s a user logged in \u0026#34;\u0026#34;\u0026#34; return current_user is not None def login_required(func): \u0026#34;\u0026#34;\u0026#34; Decorator to ensure the user is logged in before calling the function \u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): if not is_logged_in(): raise Exception(\u0026#34;You must be logged in to access this function.\u0026#34;) return func(*args, **kwargs) return wrapper @login_required def protected_function(): \u0026#34;\u0026#34;\u0026#34; Function that only executes if the user is authenticated \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Access granted to {current_user}. Running protected function.\u0026#34;) # Example usage login(\u0026#39;alice\u0026#39;, \u0026#39;password123\u0026#39;) # Log in the user protected_function() # Should work as the user is logged in logout() # Log out the user try: protected_function() # Should raise an exception as the user is not logged in except Exception as e: print(e) Input Validation with Decorators Another useful use-case is the use of decorators as input validating, which can be used to check the arguments apssed to a function before being executed. This helps maintaining clean and error-free data processing within functions\ndef validate_inputs(func): \u0026#34;\u0026#34;\u0026#34; Decorator to validate that inputs to the function are positive numbers. \u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): # Check all positional arguments for arg in args: if not isinstance(arg, (int, float)) or arg \u0026lt;= 0: raise ValueError(\u0026#34;All dimensions must be positive numbers.\u0026#34;) # Check all keyword arguments for value in kwargs.values(): if not isinstance(value, (int, float)) or value \u0026lt;= 0: raise ValueError(\u0026#34;All dimensions must be positive numbers.\u0026#34;) return func(*args, **kwargs) return wrapper @validate_inputs def calculate_area(length, width): \u0026#34;\u0026#34;\u0026#34; Calculate the area of a rectangle given length and width, both must be positive numbers. \u0026#34;\u0026#34;\u0026#34; return length * width # Example usage try: print(\u0026#34;Area:\u0026#34;, calculate_area(5, 10)) # Valid input print(\u0026#34;Area:\u0026#34;, calculate_area(-5, 10)) # This should raise an exception except ValueError as e: print(e) try: print(\u0026#34;Area:\u0026#34;, calculate_area(length=5, width=3)) # Valid input print(\u0026#34;Area:\u0026#34;, calculate_area(length=5, width=-3)) # This should raise an exception except ValueError as e: print(e) Decorators as Caching Mechanisms Decorators can also be leverage as abastract caching mechanism. Any function that is decorated with this caching function can have their results cached before being returned. The following example displays how this caching mechanism can be used with a fibonnaci function. Before the decorated function is executed, the decorator retrieves any data that is cached and passes to the fibonnaci function.\ndef memorize(func): \u0026#34;\u0026#34;\u0026#34; Decorator that caches the results of the function calls. \u0026#34;\u0026#34;\u0026#34; cache = {} # Cache to store results of expensive function calls def wrapper(*args): if args in cache: return cache[args] # Return cached result if available result = func(*args) # Calculate result since it\u0026#39;s not cached cache[args] = result # Store the new result in cache return result return wrapper @memorize def fibonacci(n): \u0026#34;\u0026#34;\u0026#34; Recursive function to calculate the nth Fibonacci number. \u0026#34;\u0026#34;\u0026#34; if n in (0, 1): # Base cases return n return fibonacci(n-1) + fibonacci(n-2) # Recursive call # Example usage print(f\u0026#34;Fibonacci 10: {fibonacci(10)}\u0026#34;) # This should compute and then cache all values up to Fib(10) print(f\u0026#34;Fibonacci 20: {fibonacci(20)}\u0026#34;) # This should use cached values for Fib(0) to Fib(10) and compute the rest Enrinching Metadata with Decorators Decorators could be used to enrich metadata by appending additional information to the output of a function. The following example displays a nested decorator, which enriches the output of the decorated function.\ndef enrich_output(unit): \u0026#34;\u0026#34;\u0026#34; Decorator to enrich function outputs with additional data such as units. \u0026#34;\u0026#34;\u0026#34; def decorator(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) # Get the original function result enriched_result = { \u0026#39;value\u0026#39;: result, \u0026#39;units\u0026#39;: unit } # Enrich the output with additional information return enriched_result return wrapper return decorator @enrich_output(\u0026#39;square meters\u0026#39;) def calculate_area(length, width): \u0026#34;\u0026#34;\u0026#34; Calculate the area of a rectangle given length and width. \u0026#34;\u0026#34;\u0026#34; return length * width # Example usage area = calculate_area(5, 10) print(area) # Output will be a dictionary with the area and the units Event Handling with Decorators Flask uses decorators to handle events. When a request is done to a specific Flask endpoint, Flask treats the HTTP request and triggers an action described in the decorated function. Then, when the function finishes execution, it takes the output and transforms it into a HTTP response.\nimport functools import logging # Setting up logging logging.basicConfig(level=logging.INFO) def event_notifier(func): \u0026#34;\u0026#34;\u0026#34; Decorator to notify events when the function is called and after it completes. \u0026#34;\u0026#34;\u0026#34; @functools.wraps(func) def wrapper(*args, **kwargs): logging.info(f\u0026#34;Function {func.__name__} called with args: {args} and kwargs: {kwargs}\u0026#34;) try: result = func(*args, **kwargs) logging.info(f\u0026#34;Function {func.__name__} completed successfully with result: {result}\u0026#34;) return result except Exception as e: logging.error(f\u0026#34;Function {func.__name__} raised an error: {e}\u0026#34;) raise # Re-raise the exception after logging it return wrapper @event_notifier def add_numbers(a, b): \u0026#34;\u0026#34;\u0026#34; Adds two numbers and returns the result. \u0026#34;\u0026#34;\u0026#34; return a + b @event_notifier def fail_function(): \u0026#34;\u0026#34;\u0026#34; A function designed to fail to demonstrate error logging. \u0026#34;\u0026#34;\u0026#34; raise ValueError(\u0026#34;Intentional error for demonstration.\u0026#34;) # Example usage print(\u0026#34;Result of add_numbers:\u0026#34;, add_numbers(5, 10)) # Should log call and completion try: fail_function() # Should log the call and the error except ValueError as e: print(f\u0026#34;Caught an error: {e}\u0026#34;) Class Decorators As explained before, decorators aren\u0026rsquo;t restricted to functions, they can also be used to extend a class functionality. They can be used to extend the functionality of several classes with additional methods, or alter existing methods. This is commonly used in framewors or libraries where certain behaviors need to be standardized across multiple classes. Decorators should be used in lieu of inheritance where flexibility and reusability are needed, improving the seperation of concerns. They can be dynamically applyed, meaning, they are applied at runtime, depending on the conditions of the program\u0026rsquo;s execution or configuration.\ndef add_logging(cls): class WrappedClass(cls): def log_method(self, method_name): print(f\u0026#34;Method {method_name} started\u0026#34;) result = method_name() print(f\u0026#34;Method {method_name} ended\u0026#34;) return result def __getattr__(self, name): attr = getattr(super(), name) if callable(attr): def wrapper(*args, **kwargs): return self.log_method(lambda: attr(*args, **kwargs)) return wrapper return attr return WrappedClass @add_logging class SomeClass: def method_one(self): print(\u0026#34;Executing method one\u0026#34;) def method_two(self): print(\u0026#34;Executing method two\u0026#34;) obj = SomeClass() obj.method_one() ### Ensure Classes Adhere to Interface\nFurthermore, decorators can be used to ensure that certain classes adhere to a defined interface or abstract base class without using inheritance. This is particularly useful in large systems adhering to strict architectural patterns where specific methods must be implemented by multiple classes:\ndef ensure_interface(interface): def decorator(cls): missing_methods = [m for m in interface if not hasattr(cls, m)] if missing_methods: raise TypeError(f\u0026#34;Class {cls.__name__} does not implement {missing_methods}\u0026#34;) return cls return decorator @ensure_interface([\u0026#39;process\u0026#39;, \u0026#39;validate\u0026#39;]) class Processor: def process(self): pass # Implement the required method # Validate method is intentionally missing to show the error # This will raise a TypeError indicating the \u0026#39;validate\u0026#39; method is missing. Singletons Finally, decorators can be used to enforce the singleton pattern, limiting a class to a single instance throughout the lifetime of a program. This is commonly used in cases you need a controlled access point to a resrouce, such as a database connection or a configuration manager.\ndef singleton(cls): instances = {} def get_instance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return get_instance @singleton class DatabaseConnection: def __init__(self): self.status = \u0026#39;Connected\u0026#39; # Both instances will actually be the same object db1 = DatabaseConnection() db2 = DatabaseConnection() print(db1 is db2) # Outputs: True ","permalink":"http://localhost:1313/posts/pythondecorators/","summary":"\u003cp\u003ePython is renowned for its exceptional versatility, making it ideal for diverse applications, from web development to data science. In this blog post, we\u0026rsquo;re diving into a powerful feature known as Decorators. Although I had not explored Decorators for quite some time, I decided it was finally time to thoroughly understand and master them.\u003c/p\u003e\n\u003ch2 id=\"understanding-nested-functions-in-python\"\u003eUnderstanding Nested Functions in Python\u003c/h2\u003e\n\u003cp\u003eBefore diving into decorators, it\u0026rsquo;s helpful to understand nested functions in Python. A nested function is defined within another function, and it can access variables from the enclosing scope. Here’s an example to illustrate this:\u003c/p\u003e","title":"Decorators in Python"},{"content":"After one year in my PhD, I accumulated a lot of notes, both hand-written or written using tools like Obsidian, Notion, or similar. I\u0026rsquo;ve loss track of most notes I took, and do not actively keep track of most. I thought a blog was exactly what I needed, somewhere to discuss more in depth some of the work I\u0026rsquo;m developing, and other projects I come across.\nI hope this blog comes to serve some use to at least me - a place where I can develop further certain ideas, skills, and other tid bits I might find interesting.\nIf you want to follow what I\u0026rsquo;m working on, there always my GitHub.\n","permalink":"http://localhost:1313/posts/introduction/","summary":"\u003cp\u003eAfter one year in my PhD, I accumulated a lot of notes, both hand-written or written using tools like Obsidian, Notion, or similar. I\u0026rsquo;ve loss track of most notes I took, and do not actively keep track of most. I thought a blog was exactly what I needed, somewhere to discuss more in depth some of the work I\u0026rsquo;m developing, and other projects I come across.\u003c/p\u003e\n\u003cp\u003eI hope this blog comes to serve some use to at least me - a place where I can develop further certain ideas, skills, and other tid bits I might find interesting.\u003c/p\u003e","title":"Introduction"}]