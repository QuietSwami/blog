<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Generators and Iterators | Francisco Mendonca&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications.">
<meta name="author" content="Francisco Mendonca">
<link rel="canonical" href="http://localhost:1313/posts/generators-and-iterators/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/generators-and-iterators/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Generators and Iterators" />
<meta property="og:description" content="Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/generators-and-iterators/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-20T16:35:06+02:00" />
<meta property="article:modified_time" content="2024-05-20T16:35:06+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Generators and Iterators"/>
<meta name="twitter:description" content="Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Generators and Iterators",
      "item": "http://localhost:1313/posts/generators-and-iterators/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Generators and Iterators",
  "name": "Generators and Iterators",
  "description": "Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications.",
  "keywords": [
    
  ],
  "articleBody": "Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications.\nAn iterator is an object that enables a programmer to traverse through all the elements of a collection, such as lists, tuples, dictionaries, and sets. This object adheres to the iterator protocol, which requires it to implement two specific methods: iter() and next(). The iter() method returns the iterator object itself and is used in conjunction with loops, like for and while, to repeatedly fetch the next element. The next() method, on the other hand, provides the next element of the collection and raises a StopIteration exception when there are no more elements to return. This mechanism underlies many of Python’s built-in functions and constructs, such as loops and comprehensions, allowing them to operate transparently over collections of data.\nGenerators are a type of iterable in Python that are used to generate a sequence of values. Unlike regular functions that return a single value and terminate, generators yield multiple values sequentially, pausing after each yield and resuming from where they left off. This is accomplished using the yield keyword. Generators are particularly useful for creating efficient, clean code, especially when dealing with large data sets or streams, as they provide values on demand and consume memory only when generating values. By maintaining state in local variables and control flow, generators facilitate complex computations without sacrificing readability or efficiency of the code. Essentially, they allow programmers to write a function that can send back a value and later resume to pick up where it left off.\nOverview of iter() and next() functions The iter() and next() functions are fundamental to the functionality of iterators in Python, facilitating the process of iterating over iterable objects such as lists, tuples, and dictionaries. Understanding how these functions operate is key to leveraging Python’s iteration capabilities more effectively.\niter() Function The iter() function is used to obtain an iterator from an iterable object. An iterable is any Python object capable of returning its members one at a time, permitting it to be iterated over in a loop. Common iterables include all types of collections, such as lists, tuples, and dictionaries. To make an object iterable, it typically needs to implement the __iter__() method, which returns an iterator object. This iterator object then processes the elements of the iterable one at a time.\nWhen iter(object) is called, Python internally calls object.__iter__() and returns an iterator for that object. If the object does not implement __iter__() but has a __getitem__() method, Python creates an iterator that attempts to fetch elements sequentially starting from index 0, raising an IndexError when no more elements are available.\nnext() Function Once an iterator is obtained using iter(), the next() function is used to sequentially access elements from the iterator. Calling next(iterator) internally invokes the iterator’s __next__() method, which returns the next available item from the iterable. If no more elements are available, it raises the StopIteration exception, signaling that the iteration is complete.\nThe use of next() is essential in low-level operations where control over the iteration process is required. This function allows developers to manually control the iteration, fetching the next element only when needed. This is particularly useful in scenarios where the iteration may need to be paused, altered, or conditionally advanced.\nPractical Usage Together, iter() and next() offer a powerful mechanism for custom iteration without the need for explicit loop constructs like for or while. This can lead to more expressive, efficient, and readable code, especially in situations involving advanced iteration patterns or when integrating with other Python features like generators and coroutines.\nBy using these functions, Python programmers can create highly efficient and lazy evaluations of potentially large datasets, manage streams of data in real-time, or implement custom iteration logic that goes beyond traditional loop constructs. Thus, understanding and using iter() and next() not only enriches one’s grasp of Python’s iteration model but also opens up possibilities for writing more pythonic and performance-oriented code.\nDeep Dive into Iterators One of the key features of iterators is their ability to maintain state. When you create an iterator, it internally keeps track of its position within the iterable. Each call to next() advances the position and returns the corresponding element. This statefulness allows iterators to handle large datasets efficiently, as they only process elements on demand and do not require the entire dataset to be loaded into memory.\nIterators are designed to be lazy, meaning they only compute and retrieve elements as they are needed. This on-demand way of fetching items makes iterators particularly useful for working with large datasets or data streams where you don’t want to consume resources for the entire data at once.\nCreating Custom Iterators Creating custom iterators can be very beneficial for handling specific types of data processing or implementing complex iteration logic. Here are some important use-cases for custom iterators in Python, with implementation examples for each.\n1. Iterating Over Infinite Sequences One common use-case is to generate infinite sequences, which can be particularly useful for generating an endless supply of data on-demand.\nclass InfiniteCounter: def __init__(self, start=0): self.current = start def __iter__(self): return self def __next__(self): current_value = self.current self.current += 1 return current_value # Usage: counter = InfiniteCounter(10) for num in counter: if num \u003e 20: break print(num) This iterator starts counting from the specified number and increments indefinitely until the loop is manually stopped.\n2. Accessing Tree-like Data Structure Navigating complex data structures, like trees, can benefit from custom iterators that yield elements in a specified traversal order.\nclass TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self, root): self.root = root def __iter__(self): return self.in_order_traversal(self.root) def in_order_traversal(self, node): if node: yield from self.in_order_traversal(node.left) yield node.val yield from self.in_order_traversal(node.right) # Usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) tree = BinaryTree(root) for value in tree: print(value) This example yields nodes’ values in in-order (left-root-right) sequence.\n3. Reading Large Files Line by Line Reading large files efficiently without loading the entire file into memory can be achieved with a custom iterator.\nclass FileIterator: def __init__(self, filepath): self.filepath = filepath def __iter__(self): self.file = open(self.filepath, 'r') return self def __next__(self): line = self.file.readline() if line == '': self.file.close() raise StopIteration return line.strip() # Usage: file_iter = FileIterator('example.txt') for line in file_iter: print(line) This iterator reads a file line by line, making it ideal for processing large text files.\n4. Cycling Through a Collection Cycling through a list or any collection repeatedly can be useful for simulations or games.\nclass Cycle: def __init__(self, data): self.data = data self.index = 0 def __iter__(self): return self def __next__(self): if not self.data: raise StopIteration result = self.data[self.index % len(self.data)] self.index += 1 return result # Usage: cycler = Cycle([1, 2, 3]) for _ in range(10): print(next(cycler), end=' ') # Prints: 1 2 3 1 2 3 1 2 3 1 This iterator repeats the elements in the list indefinitely.\nThese examples showcase how custom iterators can be tailored to fit specific needs, enhancing the functionality and efficiency of Python applications.\nPython’s built-in iterators Another way to improve performance and readability of your Python code it’s the built-in interators. They offer a streamlined and efficient mechanism to traverse various data types. Here, we’ll explore some of the most commonly used built-in iterators and how they facilitate opereation on Python’s data structures.\nIterators from Collections Lists, Tuples, Strings, and Sets\nAll of these data types are iterable, meaning you can use a loop directly on them, which implicitly creates an iterator:\nmy_list = [1, 2, 3] for item in my_list: print(item) When you use a loop on these collections, Python internally calls iter() on the collection, which returns an iterator that goes through each element until it raises a StopIteration exception, signaling that there are no more elements.\nDictionaries\nKeys: By default, iterating over a dictionary iterates over its keys.\nmy_dict = {'a': 1, 'b': 2} for key in my_dict: print(key) # Outputs 'a' 'b' Values: To iterate over the values, you use .values().\nfor value in my_dict.values(): print(value) # Outputs 1 2 Items: To iterate over the items as key-value pairs, you use .items().\nfor key, value in my_dict.items(): print(key, value) # Outputs 'a' 1, 'b' 2 File Iterators When you open a file in Python, you can iterate over its lines directly, which is much more memory-efficient than loading the entire file into a list:\nwith open('example.txt', 'r') as file: for line in file: print(line.strip()) This method is particularly useful for processing large files, as it reads one line at a time directly from the file stream.\nrange() Iterator The range() function returns an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops:\nfor i in range(5): print(i) # Outputs 0 1 2 3 4 range() is especially efficient because it generates each number on the fly and does not store the entire range in memory.\nzip() Iterator zip() is used to iterate over several iterables in parallel, producing tuples containing elements from each iterable:\nnames = ['Alice', 'Bob', 'Charlie'] scores = [85, 90, 88] for name, score in zip(names, scores): print(f\"{name}: {score}\") zip() stops when the shortest iterable is exhausted.\nenumerator() Iterator enumerate() adds a counter to an iterable and returns it in a form of enumerate object. This can be directly used in for loops to get index-value pairs:\nfor index, value in enumerate(['a', 'b', 'c']): print(f\"{index}: {value}\") reversed() Iterator reversed() returns a reverse iterator that accesses the given sequence in the reverse order:\nfor char in reversed(\"hello\"): print(char) Understanding Generators Generators are a special type of iterator in Python that allow you to declare a function that behaves like an iterator, i.e., it can be used in a loop to return data one at a time. They provide a very powerful and versatile mechanism to handle sequences of data without needing to store them in memory all at once. Understanding how generators differ from regular functions and how they manage state can greatly enhance your ability to write efficient and effective Python code.\n1. Return Type and Behavior:\nNormal Function: A normal function processes its inputs and computes a result. Once a function executes the return statement, it completes its execution and returns control back to the caller along with any result, terminating the process.\nGenerator Function: Instead of returning a final result, a generator function yields a sequence of results over time, pausing after each yield and resuming from where it left off. This is done using the yield keyword instead of return. Unlike a regular function, which terminates after a return statement is executed, a generator function is designed to suspend and resume its execution and state around the last point of value generation.\n2. Memory Utilization:\nNormal Function: When invoked, a normal function must compute and return its entire result set at once, which can be a problem with large data sets due to memory constraints.\nGenerator Function: Generators yield items one at a time, only when required, thus occupying memory only for the item that is currently being processed. This makes them extremely memory efficient, particularly for large datasets and streams.\n3. Use Cases:\nNormal Function: Best used when you need to compute and use all results at once, or when the outputs are independent of the function’s state. Generator Function: Ideal for large data processing tasks, lazy evaluations, or when the complete data set does not need to be held in memory simultaneously. They are also great for pipelines where data flows through a series of processing steps.\nHow Generators Save State Generators in Python automatically maintain their states in the background, which allows them to resume where they left off when next() is called again. Here’s how they manage this:\n1. Local Variables and Execution State: Generators save their local variables and execution state between yields. When a generator yields, the state of the local variables and the point in the code execution is saved. The next time the generator’s next() method is invoked, it resumes right after the last yield run.\n2. Automatic State Management: The state management is handled automatically by Python, so developers do not need to write additional code to manage state, which simplifies the creation of iterators considerably and reduces the chance of bugs.\n3. Yield Keyword: The yield keyword is pivotal in a generator. When Python encounters yield, it sends the yielded value back to the caller but retains enough state to enable the function to be resumed right after the yield. This contrasts sharply with return, which exits a function entirely, cleaning up the local namespace.\n4. Generator Object: When a generator function is called, Python returns a generator object that can be iterated over, rather than executing the function. This object represents an ongoing generator process, with methods like next() to manually fetch the next value and send() to alter the flow of the generator.\nBy leveraging the ability of generators to yield multiple values sequentially and save their execution state between yields, Python programmers can handle data streams more efficiently and with greater control than is possible using only regular functions. This makes generators an essential tool in the Python programming toolkit, especially for applications involving large data processing or that require lazy execution.\nWriting Generator Functions This section explores how to write generator functions using the yield statement, provides examples of simple generator functions, and discusses the advantages of using generators, particularly focusing on memory efficiency and their capability to represent infinite sequences.\nThe yield statement is used in generator functions to specify that the function should return a value but suspend its state until it is called again. Unlike return, which exits a function entirely after executing, yield pauses the function, saving its state, and later resumes from where it left off. Here’s how to use it:\ndef generator_function(): yield value Each time the generator’s next() method is called, the function executes or resumes execution until it encounters a yield statement. After yielding, the function state is suspended, awaiting the next call.\nExamples of Simple Generator Functions This generator function counts indefinitely from a given number.\ndef count_from(start): while True: yield start start += 1 counter = count_from(10) print(next(counter)) # 10 print(next(counter)) # 11 Generates the Fibonacci sequence, where each number is the sum of the two preceding ones.\ndef fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b fib = fibonacci() for _ in range(5): print(next(fib)) # Outputs: 0, 1, 1, 2, 3 Advantages of Generators\nMemory Efficiency Generators are highly memory-efficient. They yield one item at a time, only holding the last generated item in memory. This is particularly beneficial when working with large data sets, as it means not all data must be loaded into memory at once, unlike list comprehensions or storing entire data sets in lists.\nRepresenting Infinite Sequences Generators are ideal for representing infinite sequences. They allow the generation of data elements on-the-fly and do not require the data to fit into memory. This makes generators perfect for generating an unlimited series of values, such as infinite mathematical sequences or continuous data streams.\nNon-blocking Behaviour Generators can yield control back to the event loop, allowing other operations to run while waiting for an operation to complete. This is akin to non-blocking IO operations where the system can continue performing other tasks while waiting for data from a network request or file IO.\nEasier Error Handling and Resource Management In asynchronous programming, managing resources and errors can be complex due to the non-linear execution flow. Generators simplify these tasks by using yield in a context that naturally supports exception handling and cleanup actions.\nStreamlined Syntax for Asynchronous Code By using generator-based coroutines (prior to the introduction of async/await), Python allowed developers to write asynchronous code that looks and behaves like synchronous procedural code. This helps in reducing cognitive load and simplifying the codebase.\nHere’s an illustrative example, using Python’s older coroutine style with generators in an asynchronous task:\nimport time def asynchronous_task(): def task(): print(\"Start task\") time.sleep(3) # Simulate a blocking operation print(\"Finish task\") def after_task(): print(\"Callback after task\") yield task() # Yield execution to run the task yield after_task() # Continue with the rest after yielding back # Simulate event loop processing gen = asynchronous_task() next(gen) # Execute task next(gen) # Execute after_task In this way, generators provide a foundational technique for managing asynchronous operations, showcasing their versatility beyond simple iteration and memory efficiency. This advantage remains highly relevant even as modern Python uses async and await for asynchronous programming, reflecting the principles first pioneered by generators.\nAdvanced Generator Features Generators in Python are not just simple iterators; they come equipped with advanced capabilities that can significantly enhance your programming, especially when dealing with complex workflows and data processing tasks. These advanced features include sending values to generators, using yield from for delegation, and building data pipelines. Let’s delve into each of these features:\nSending Values to Generators Generators can not only yield values but also receive information at the point of each yield, enabling a two-way exchange between the generator and its caller. This is accomplished using the send() method, which resumes the generator’s execution and simultaneously sends a value back to the generator. This value can be used inside the generator, typically to influence its behavior.\ndef ping_pong(): ball = yield \"Ping\" while True: if ball == \"Ping\": ball = yield \"Pong\" else: ball = yield \"Ping\" # Create generator game = ping_pong() print(next(game)) # Start the game, prints \"Ping\" print(game.send(\"Ping\")) # Send \"Ping\", prints \"Pong\" print(game.send(\"Pong\")) # Send \"Pong\", prints \"Ping\" In this example, the ping_pong generator keeps alternating responses based on the value sent to it. The initial call to next() is required to start the generator.\nSimplifying Generator Delegation\ndef count_up_to(max): count = 1 while count \u003c= max: yield count count += 1 def count_down_from(max): yield from count_up_to(max) while max \u003e 0: yield max max -= 1 # Usage counter = count_down_from(3) for x in counter: print(x) # Outputs: 1, 2, 3, 3, 2, 1 This example demonstrates using yield from to delegate the counting up part to another generator, which the count_down_from function then extends to count back down. The yield from expression is used in Python generators to delegate part of its operation to another generator. This provides a way to compose generators together, allowing one generator to yield all values from another generator before continuing with its own execution.\nIn the count_down_from function, yield from is used to incorporate all the values from the count_up_to generator into the count_down_from generator. Here’s what happens step-by-step:\nExecution of count_up_to: When count_down_from reaches the line with yield from count_up_to(max), it starts executing the count_up_to generator. Yielding from count_up_to: The count_up_to generator begins to yield values from 1 up to the maximum value (max). Each value yielded by count_up_to is passed directly to the caller of count_down_from—as if count_down_from were yielding these values itself. Completion of count_up_to: Once count_up_to has yielded all its values and completes, control returns to count_down_from. Importantly, count_up_to needs to complete all its yields (i.e., it has to exhaust all its values by reaching its own end) before count_down_from continues beyond the yield from expression. Continuation of count_down_from: After count_up_to finishes, count_down_from resumes execution immediately after the yield from line. It then proceeds to yield its own values, counting down from max to 1. Generators can be effectively used to build data pipelines where each generator processes some data and passes it on to the next generator in the pipeline. This modular approach can lead to clean and manageable code, particularly suitable for data transformations and filtering.\ndef read_logs(file_path): \"\"\"Read a log file line by line.\"\"\" with open(file_path, 'r') as file: for line in file: yield line.strip() def filter_errors(log_lines): \"\"\"Yield only error messages.\"\"\" for line in log_lines: if \"ERROR\" in line: yield line def print_errors(errors): \"\"\"Print each error line.\"\"\" for error in errors: print(error) # Build the pipeline log_path = 'server_logs.txt' log_lines = read_logs(log_path) error_lines = filter_errors(log_lines) print_errors(error_lines) This example illustrates how a data pipeline can be constructed using generators, with each function handling a specific part of the data processing, resulting in a clear and efficient workflow.\nPracticle Applications and Examples Generators are ideal for searching through data and applying filters without needing to load the entire dataset into memory. This can be particularly useful in scenarios where you are working with large amounts of data that are too big to fit into memory or when you want to apply complex filters progressively.\nSuppose you have a large log file and you need to find all entries that contain a specific error code. A generator can be used to yield only the lines that meet this criterion:\ndef filter_logs(filename, error_code): \"\"\"Generator that yields log lines containing a specific error code.\"\"\" with open(filename, 'r') as file: for line in file: if error_code in line: yield line.strip() # Usage error_entries = filter_logs('system_logs.txt', 'Error 404') for entry in error_entries: print(entry) In this example, the generator filter_logs reads the log file line by line, yielding only the lines that contain the specified error_code. This approach ensures that memory usage is minimal since only one line is held in memory at a time.\nReading large files is another practical application for generators, allowing for efficient processing of each line without the need for loading the entire file content into memory. This method is especially beneficial for handling large datasets, logs, or any large text files.\nImagine you have a large file containing financial transaction records, and you need to process each transaction to compute the total or apply some other analysis:\ndef read_transactions(file_path): \"\"\"Generator that yields each transaction from a file.\"\"\" with open(file_path, 'r') as file: next(file) # Skip the header line if there is one for line in file: data = line.strip().split(',') transaction = { 'date': data[0], 'amount': float(data[1]), 'description': data[2] } yield transaction # Usage total = 0 transactions = read_transactions('transactions.csv') for transaction in transactions: total += transaction['amount'] print(f\"Total amount of transactions: ${total:.2f}\") In this example, the generator read_transactions reads a CSV file containing transaction records. It processes each line individually to extract transaction details and yields a dictionary representing each transaction. This allows you to handle the processing of each record on-the-fly and compute the total amount incrementally.\nCommon Practices and Anti-Patterns Performance Considerations Conclusion ",
  "wordCount" : "3826",
  "inLanguage": "en",
  "datePublished": "2024-05-20T16:35:06+02:00",
  "dateModified": "2024-05-20T16:35:06+02:00",
  "author":{
    "@type": "Person",
    "name": "Francisco Mendonca"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/generators-and-iterators/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Francisco Mendonca's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Francisco Mendonca&#39;s Blog (Alt + H)">Francisco Mendonca&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Generators and Iterators
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2024-05-20 16:35:06 +0200 CEST'>May 20, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Francisco Mendonca

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#overview-of-iter-and-next-functions" aria-label="Overview of iter() and next() functions">Overview of iter() and next() functions</a><ul>
                        
                <li>
                    <a href="#iter-function" aria-label="iter() Function">iter() Function</a></li>
                <li>
                    <a href="#next-function" aria-label="next() Function">next() Function</a></li>
                <li>
                    <a href="#practical-usage" aria-label="Practical Usage">Practical Usage</a></li></ul>
                </li>
                <li>
                    <a href="#deep-dive-into-iterators" aria-label="Deep Dive into Iterators">Deep Dive into Iterators</a><ul>
                        
                <li>
                    <a href="#creating-custom-iterators" aria-label="Creating Custom Iterators">Creating Custom Iterators</a><ul>
                        
                <li>
                    <a href="#1-iterating-over-infinite-sequences" aria-label="1. Iterating Over Infinite Sequences">1. Iterating Over Infinite Sequences</a></li>
                <li>
                    <a href="#2-accessing-tree-like-data-structure" aria-label="2. Accessing Tree-like Data Structure">2. Accessing Tree-like Data Structure</a></li>
                <li>
                    <a href="#3-reading-large-files-line-by-line" aria-label="3. Reading Large Files Line by Line">3. Reading Large Files Line by Line</a></li>
                <li>
                    <a href="#4-cycling-through-a-collection" aria-label="4. Cycling Through a Collection">4. Cycling Through a Collection</a></li></ul>
                </li>
                <li>
                    <a href="#pythons-built-in-iterators" aria-label="Python&rsquo;s built-in iterators">Python&rsquo;s built-in iterators</a><ul>
                        
                <li>
                    <a href="#iterators-from-collections" aria-label="Iterators from Collections">Iterators from Collections</a></li>
                <li>
                    <a href="#file-iterators" aria-label="File Iterators">File Iterators</a></li>
                <li>
                    <a href="#range-iterator" aria-label="range() Iterator">range() Iterator</a></li>
                <li>
                    <a href="#zip-iterator" aria-label="zip() Iterator">zip() Iterator</a></li>
                <li>
                    <a href="#enumerator-iterator" aria-label="enumerator() Iterator">enumerator() Iterator</a></li>
                <li>
                    <a href="#reversed-iterator" aria-label="reversed() Iterator">reversed() Iterator</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#understanding-generators" aria-label="Understanding Generators">Understanding Generators</a><ul>
                        
                <li>
                    <a href="#how-generators-save-state" aria-label="How Generators Save State">How Generators Save State</a></li>
                <li>
                    <a href="#writing-generator-functions" aria-label="Writing Generator Functions">Writing Generator Functions</a><ul>
                        
                <li>
                    <a href="#examples-of-simple-generator-functions" aria-label="Examples of Simple Generator Functions">Examples of Simple Generator Functions</a></li></ul>
                </li>
                <li>
                    <a href="#advanced-generator-features" aria-label="Advanced Generator Features">Advanced Generator Features</a></li></ul>
                </li>
                <li>
                    <a href="#practicle-applications-and-examples" aria-label="Practicle Applications and Examples">Practicle Applications and Examples</a></li>
                <li>
                    <a href="#common-practices-and-anti-patterns" aria-label="Common Practices and Anti-Patterns">Common Practices and Anti-Patterns</a></li>
                <li>
                    <a href="#performance-considerations" aria-label="Performance Considerations">Performance Considerations</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Python stands out as an exceptionally user-friendly programming language, offering straightforward fundamental concepts ideal for newcomers to coding. However, it also boasts several advanced features that enhance performance significantly. Among these features, Generators and Iterators are particularly noteworthy within the Python ecosystem. These tools are crucial for optimizing memory usage and implementing lazy evaluation, allowing programmers to handle large data sets more efficiently without the need for extensive memory allocation. Generators and Iterators enable the creation of efficient code that is not only resource-friendly but also cleaner and more readable, demonstrating Python’s versatility from basic scripting to handling complex, large-scale applications.</p>
<p>An iterator is an object that enables a programmer to traverse through all the elements of a collection, such as lists, tuples, dictionaries, and sets. This object adheres to the iterator protocol, which requires it to implement two specific methods: <strong>iter</strong>() and <strong>next</strong>(). The <strong>iter</strong>() method returns the iterator object itself and is used in conjunction with loops, like for and while, to repeatedly fetch the next element. The <strong>next</strong>() method, on the other hand, provides the next element of the collection and raises a StopIteration exception when there are no more elements to return. This mechanism underlies many of Python&rsquo;s built-in functions and constructs, such as loops and comprehensions, allowing them to operate transparently over collections of data.</p>
<p>Generators are a type of iterable in Python that are used to generate a sequence of values. Unlike regular functions that return a single value and terminate, generators yield multiple values sequentially, pausing after each yield and resuming from where they left off. This is accomplished using the yield keyword. Generators are particularly useful for creating efficient, clean code, especially when dealing with large data sets or streams, as they provide values on demand and consume memory only when generating values. By maintaining state in local variables and control flow, generators facilitate complex computations without sacrificing readability or efficiency of the code. Essentially, they allow programmers to write a function that can send back a value and later resume to pick up where it left off.</p>
<h2 id="overview-of-iter-and-next-functions">Overview of <code>iter()</code> and <code>next()</code> functions<a hidden class="anchor" aria-hidden="true" href="#overview-of-iter-and-next-functions">#</a></h2>
<p>The <code>iter()</code> and <code>next()</code> functions are fundamental to the functionality of iterators in Python, facilitating the process of iterating over iterable objects such as lists, tuples, and dictionaries. Understanding how these functions operate is key to leveraging Python&rsquo;s iteration capabilities more effectively.</p>
<h3 id="iter-function"><code>iter()</code> Function<a hidden class="anchor" aria-hidden="true" href="#iter-function">#</a></h3>
<p>The <code>iter()</code> function is used to obtain an iterator from an iterable object. An iterable is any Python object capable of returning its members one at a time, permitting it to be iterated over in a loop. Common iterables include all types of collections, such as lists, tuples, and dictionaries. To make an object iterable, it typically needs to implement the <code>__iter__()</code> method, which returns an iterator object. This iterator object then processes the elements of the iterable one at a time.</p>
<p>When iter(object) is called, Python internally calls object.<code>__iter__()</code> and returns an iterator for that object. If the object does not implement <code>__iter__()</code> but has a <code>__getitem__()</code> method, Python creates an iterator that attempts to fetch elements sequentially starting from index 0, raising an IndexError when no more elements are available.</p>
<h3 id="next-function"><code>next()</code> Function<a hidden class="anchor" aria-hidden="true" href="#next-function">#</a></h3>
<p>Once an iterator is obtained using <code>iter()</code>, the <code>next()</code> function is used to sequentially access elements from the iterator. Calling <code>next(iterator)</code> internally invokes the iterator&rsquo;s <code>__next__()</code> method, which returns the next available item from the iterable. If no more elements are available, it raises the StopIteration exception, signaling that the iteration is complete.</p>
<p>The use of <code>next()</code> is essential in low-level operations where control over the iteration process is required. This function allows developers to manually control the iteration, fetching the next element only when needed. This is particularly useful in scenarios where the iteration may need to be paused, altered, or conditionally advanced.</p>
<h3 id="practical-usage">Practical Usage<a hidden class="anchor" aria-hidden="true" href="#practical-usage">#</a></h3>
<p>Together, <code>iter()</code> and <code>next()</code> offer a powerful mechanism for custom iteration without the need for explicit loop constructs like for or while. This can lead to more expressive, efficient, and readable code, especially in situations involving advanced iteration patterns or when integrating with other Python features like generators and coroutines.</p>
<p>By using these functions, Python programmers can create highly efficient and lazy evaluations of potentially large datasets, manage streams of data in real-time, or implement custom iteration logic that goes beyond traditional loop constructs. Thus, understanding and using <code>iter()</code> and <code>next()</code> not only enriches one&rsquo;s grasp of Python&rsquo;s iteration model but also opens up possibilities for writing more pythonic and performance-oriented code.</p>
<h2 id="deep-dive-into-iterators">Deep Dive into Iterators<a hidden class="anchor" aria-hidden="true" href="#deep-dive-into-iterators">#</a></h2>
<p>One of the key features of iterators is their ability to maintain state. When you create an iterator, it internally keeps track of its position within the iterable. Each call to <strong>next</strong>() advances the position and returns the corresponding element. This statefulness allows iterators to handle large datasets efficiently, as they only process elements on demand and do not require the entire dataset to be loaded into memory.</p>
<p>Iterators are designed to be lazy, meaning they only compute and retrieve elements as they are needed. This on-demand way of fetching items makes iterators particularly useful for working with large datasets or data streams where you don&rsquo;t want to consume resources for the entire data at once.</p>
<h3 id="creating-custom-iterators">Creating Custom Iterators<a hidden class="anchor" aria-hidden="true" href="#creating-custom-iterators">#</a></h3>
<p>Creating custom iterators can be very beneficial for handling specific types of data processing or implementing complex iteration logic. Here are some important use-cases for custom iterators in Python, with implementation examples for each.</p>
<h4 id="1-iterating-over-infinite-sequences">1. Iterating Over Infinite Sequences<a hidden class="anchor" aria-hidden="true" href="#1-iterating-over-infinite-sequences">#</a></h4>
<p>One common use-case is to generate infinite sequences, which can be particularly useful for generating an endless supply of data on-demand.</p>






<pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InfiniteCounter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">start</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">current_value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage:</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span> <span class="o">=</span> <span class="n">InfiniteCounter</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span></span></code></pre></div></pre>
<p>This iterator starts counting from the specified number and increments indefinitely until the loop is manually stopped.</p>
<h4 id="2-accessing-tree-like-data-structure">2. Accessing Tree-like Data Structure<a hidden class="anchor" aria-hidden="true" href="#2-accessing-tree-like-data-structure">#</a></h4>
<p>Navigating complex data structures, like trees, can benefit from custom iterators that yield elements in a specified traversal order.</p>






<pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">key</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">in_order_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_order_traversal</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage:</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">tree</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span></span></code></pre></div></pre>
<p>This example yields nodes&rsquo; values in in-order (left-root-right) sequence.</p>
<h4 id="3-reading-large-files-line-by-line">3. Reading Large Files Line by Line<a hidden class="anchor" aria-hidden="true" href="#3-reading-large-files-line-by-line">#</a></h4>
<p>Reading large files efficiently without loading the entire file into memory can be achieved with a custom iterator.</p>






<pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FileIterator</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">raise</span> <span class="ne">StopIteration</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage:</span>
</span></span><span class="line"><span class="cl"><span class="n">file_iter</span> <span class="o">=</span> <span class="n">FileIterator</span><span class="p">(</span><span class="s1">&#39;example.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_iter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span></span></code></pre></div></pre>
<p>This iterator reads a file line by line, making it ideal for processing large text files.</p>
<h4 id="4-cycling-through-a-collection">4. Cycling Through a Collection<a hidden class="anchor" aria-hidden="true" href="#4-cycling-through-a-collection">#</a></h4>
<p>Cycling through a list or any collection repeatedly can be useful for simulations or games.</p>






<pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cycle</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">raise</span> <span class="ne">StopIteration</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage:</span>
</span></span><span class="line"><span class="cl"><span class="n">cycler</span> <span class="o">=</span> <span class="n">Cycle</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">cycler</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>  <span class="c1"># Prints: 1 2 3 1 2 3 1 2 3 1</span>
</span></span></code></pre></div></pre>
<p>This iterator repeats the elements in the list indefinitely.</p>
<p>These examples showcase how custom iterators can be tailored to fit specific needs, enhancing the functionality and efficiency of Python applications.</p>
<h3 id="pythons-built-in-iterators">Python&rsquo;s built-in iterators<a hidden class="anchor" aria-hidden="true" href="#pythons-built-in-iterators">#</a></h3>
<p>Another way to improve performance and readability of your Python code it&rsquo;s the built-in interators. They offer a streamlined and efficient mechanism to traverse various data types. Here, we&rsquo;ll explore some of the most commonly used built-in iterators and how they facilitate opereation on Python&rsquo;s data structures.</p>
<h4 id="iterators-from-collections">Iterators from Collections<a hidden class="anchor" aria-hidden="true" href="#iterators-from-collections">#</a></h4>
<p><em>Lists, Tuples, Strings, and Sets</em></p>
<p>All of these data types are iterable, meaning you can use a loop directly on them, which implicitly creates an iterator:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span></code></pre></div><p>When you use a loop on these collections, Python internally calls iter() on the collection, which returns an iterator that goes through each element until it raises a StopIteration exception, signaling that there are no more elements.</p>
<p><em>Dictionaries</em></p>
<ul>
<li>
<p>Keys: By default, iterating over a dictionary iterates over its keys.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># Outputs &#39;a&#39; &#39;b&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>Values: To iterate over the values, you use .values().</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># Outputs 1 2</span>
</span></span></code></pre></div></li>
<li>
<p>Items: To iterate over the items as key-value pairs, you use .items().</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>  <span class="c1"># Outputs &#39;a&#39; 1, &#39;b&#39; 2</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="file-iterators">File Iterators<a hidden class="anchor" aria-hidden="true" href="#file-iterators">#</a></h4>
<p>When you open a file in Python, you can iterate over its lines directly, which is much more memory-efficient than loading the entire file into a list:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;example.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span></code></pre></div><p>This method is particularly useful for processing large files, as it reads one line at a time directly from the file stream.</p>
<h4 id="range-iterator"><code>range()</code> Iterator<a hidden class="anchor" aria-hidden="true" href="#range-iterator">#</a></h4>
<p>The range() function returns an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Outputs 0 1 2 3 4</span>
</span></span></code></pre></div><p><code>range()</code> is especially efficient because it generates each number on the fly and does not store the entire range in memory.</p>
<h4 id="zip-iterator"><code>zip()</code> Iterator<a hidden class="anchor" aria-hidden="true" href="#zip-iterator">#</a></h4>
<p><code>zip()</code> is used to iterate over several iterables in parallel, producing tuples containing elements from each iterable:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span> <span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Charlie&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">85</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">88</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">score</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>zip() stops when the shortest iterable is exhausted.</p>
<h4 id="enumerator-iterator"><code>enumerator()</code> Iterator<a hidden class="anchor" aria-hidden="true" href="#enumerator-iterator">#</a></h4>
<p><code>enumerate()</code> adds a counter to an iterable and returns it in a form of enumerate object. This can be directly used in for loops to get index-value pairs:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="reversed-iterator"><code>reversed()</code> Iterator<a hidden class="anchor" aria-hidden="true" href="#reversed-iterator">#</a></h4>
<p>reversed() returns a reverse iterator that accesses the given sequence in the reverse order:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="s2">&#34;hello&#34;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="understanding-generators">Understanding Generators<a hidden class="anchor" aria-hidden="true" href="#understanding-generators">#</a></h2>
<p>Generators are a special type of iterator in Python that allow you to declare a function that behaves like an iterator, i.e., it can be used in a loop to return data one at a time. They provide a very powerful and versatile mechanism to handle sequences of data without needing to store them in memory all at once. Understanding how generators differ from regular functions and how they manage state can greatly enhance your ability to write efficient and effective Python code.</p>
<p><strong>1. Return Type and Behavior:</strong></p>
<p><em>Normal Function</em>: A normal function processes its inputs and computes a result. Once a function executes the return statement, it completes its execution and returns control back to the caller along with any result, terminating the process.</p>
<p><em>Generator Function</em>: Instead of returning a final result, a generator function yields a sequence of results over time, pausing after each yield and resuming from where it left off. This is done using the yield keyword instead of return. Unlike a regular function, which terminates after a return statement is executed, a generator function is designed to suspend and resume its execution and state around the last point of value generation.</p>
<p><strong>2. Memory Utilization:</strong></p>
<p><em>Normal Function</em>: When invoked, a normal function must compute and return its entire result set at once, which can be a problem with large data sets due to memory constraints.</p>
<p><em>Generator Function</em>: Generators yield items one at a time, only when required, thus occupying memory only for the item that is currently being processed. This makes them extremely memory efficient, particularly for large datasets and streams.</p>
<p><strong>3. Use Cases:</strong></p>
<p><em>Normal Function</em>: Best used when you need to compute and use all results at once, or when the outputs are independent of the function&rsquo;s state.
<em>Generator Function</em>: Ideal for large data processing tasks, lazy evaluations, or when the complete data set does not need to be held in memory simultaneously. They are also great for pipelines where data flows through a series of processing steps.</p>
<h3 id="how-generators-save-state">How Generators Save State<a hidden class="anchor" aria-hidden="true" href="#how-generators-save-state">#</a></h3>
<p>Generators in Python automatically maintain their states in the background, which allows them to resume where they left off when next() is called again. Here’s how they manage this:</p>
<p><strong>1. Local Variables and Execution State:</strong>
Generators save their local variables and execution state between yields. When a generator yields, the state of the local variables and the point in the code execution is saved. The next time the generator&rsquo;s next() method is invoked, it resumes right after the last yield run.</p>
<p><strong>2. Automatic State Management:</strong>
The state management is handled automatically by Python, so developers do not need to write additional code to manage state, which simplifies the creation of iterators considerably and reduces the chance of bugs.</p>
<p><strong>3. Yield Keyword:</strong>
The yield keyword is pivotal in a generator. When Python encounters yield, it sends the yielded value back to the caller but retains enough state to enable the function to be resumed right after the yield. This contrasts sharply with return, which exits a function entirely, cleaning up the local namespace.</p>
<p><strong>4. Generator Object:</strong>
When a generator function is called, Python returns a generator object that can be iterated over, rather than executing the function. This object represents an ongoing generator process, with methods like <strong>next</strong>() to manually fetch the next value and send() to alter the flow of the generator.</p>
<p>By leveraging the ability of generators to yield multiple values sequentially and save their execution state between yields, Python programmers can handle data streams more efficiently and with greater control than is possible using only regular functions. This makes generators an essential tool in the Python programming toolkit, especially for applications involving large data processing or that require lazy execution.</p>
<h3 id="writing-generator-functions">Writing Generator Functions<a hidden class="anchor" aria-hidden="true" href="#writing-generator-functions">#</a></h3>
<p>This section explores how to write generator functions using the <code>yield</code> statement, provides examples of simple generator functions, and discusses the advantages of using generators, particularly focusing on memory efficiency and their capability to represent infinite sequences.</p>
<p>The <code>yield</code> statement is used in generator functions to specify that the function should return a value but suspend its state until it is called again. Unlike return, which exits a function entirely after executing, <code>yield</code> pauses the function, saving its state, and later resumes from where it left off. Here&rsquo;s how to use it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generator_function</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="n">value</span>
</span></span></code></pre></div><p>Each time the generator&rsquo;s next() method is called, the function executes or resumes execution until it encounters a yield statement. After yielding, the function state is suspended, awaiting the next call.</p>
<h4 id="examples-of-simple-generator-functions">Examples of Simple Generator Functions<a hidden class="anchor" aria-hidden="true" href="#examples-of-simple-generator-functions">#</a></h4>
<p>This generator function counts indefinitely from a given number.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count_from</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">start</span>
</span></span><span class="line"><span class="cl">        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">counter</span> <span class="o">=</span> <span class="n">count_from</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">))</span>  <span class="c1"># 10</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">))</span>  <span class="c1"># 11</span>
</span></span></code></pre></div><p>Generates the Fibonacci sequence, where each number is the sum of the two preceding ones.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">fib</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">fib</span><span class="p">))</span>  <span class="c1"># Outputs: 0, 1, 1, 2, 3</span>
</span></span></code></pre></div><p><em>Advantages of Generators</em></p>
<ol>
<li>Memory Efficiency</li>
</ol>
<p>Generators are highly memory-efficient. They yield one item at a time, only holding the last generated item in memory. This is particularly beneficial when working with large data sets, as it means not all data must be loaded into memory at once, unlike list comprehensions or storing entire data sets in lists.</p>
<ol start="2">
<li>Representing Infinite Sequences</li>
</ol>
<p>Generators are ideal for representing infinite sequences. They allow the generation of data elements on-the-fly and do not require the data to fit into memory. This makes generators perfect for generating an unlimited series of values, such as infinite mathematical sequences or continuous data streams.</p>
<ol start="3">
<li>Non-blocking Behaviour</li>
</ol>
<p>Generators can yield control back to the event loop, allowing other operations to run while waiting for an operation to complete. This is akin to non-blocking IO operations where the system can continue performing other tasks while waiting for data from a network request or file IO.</p>
<ol start="4">
<li>Easier Error Handling and Resource Management</li>
</ol>
<p>In asynchronous programming, managing resources and errors can be complex due to the non-linear execution flow. Generators simplify these tasks by using <code>yield</code> in a context that naturally supports exception handling and cleanup actions.</p>
<ol start="5">
<li>Streamlined Syntax for Asynchronous Code</li>
</ol>
<p>By using generator-based coroutines (prior to the introduction of <code>async</code>/<code>await</code>), Python allowed developers to write asynchronous code that looks and behaves like synchronous procedural code. This helps in reducing cognitive load and simplifying the codebase.</p>
<p>Here’s an illustrative example, using Python&rsquo;s older coroutine style with generators in an asynchronous task:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">asynchronous_task</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">task</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Start task&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Simulate a blocking operation</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Finish task&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">after_task</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Callback after task&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="n">task</span><span class="p">()</span>  <span class="c1"># Yield execution to run the task</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="n">after_task</span><span class="p">()</span>  <span class="c1"># Continue with the rest after yielding back</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Simulate event loop processing</span>
</span></span><span class="line"><span class="cl"><span class="n">gen</span> <span class="o">=</span> <span class="n">asynchronous_task</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>  <span class="c1"># Execute task</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>  <span class="c1"># Execute after_task</span>
</span></span></code></pre></div><p>In this way, generators provide a foundational technique for managing asynchronous operations, showcasing their versatility beyond simple iteration and memory efficiency. This advantage remains highly relevant even as modern Python uses <code>async</code> and <code>await</code> for asynchronous programming, reflecting the principles first pioneered by generators.</p>
<h3 id="advanced-generator-features">Advanced Generator Features<a hidden class="anchor" aria-hidden="true" href="#advanced-generator-features">#</a></h3>
<p>Generators in Python are not just simple iterators; they come equipped with advanced capabilities that can significantly enhance your programming, especially when dealing with complex workflows and data processing tasks. These advanced features include sending values to generators, using <code>yield</code> from for delegation, and building data pipelines. Let&rsquo;s delve into each of these features:</p>
<p><em>Sending Values to Generators</em>
Generators can not only yield values but also receive information at the point of each yield, enabling a two-way exchange between the generator and its caller. This is accomplished using the send() method, which resumes the generator’s execution and simultaneously sends a value back to the generator. This value can be used inside the generator, typically to influence its behavior.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ping_pong</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">ball</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&#34;Ping&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">ball</span> <span class="o">==</span> <span class="s2">&#34;Ping&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">ball</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&#34;Pong&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">ball</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&#34;Ping&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Create generator</span>
</span></span><span class="line"><span class="cl"><span class="n">game</span> <span class="o">=</span> <span class="n">ping_pong</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">game</span><span class="p">))</span>      <span class="c1"># Start the game, prints &#34;Ping&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&#34;Ping&#34;</span><span class="p">))</span>  <span class="c1"># Send &#34;Ping&#34;, prints &#34;Pong&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&#34;Pong&#34;</span><span class="p">))</span>  <span class="c1"># Send &#34;Pong&#34;, prints &#34;Ping&#34;</span>
</span></span></code></pre></div><p>In this example, the ping_pong generator keeps alternating responses based on the value sent to it. The initial call to next() is required to start the generator.</p>
<p><em>Simplifying Generator Delegation</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count_up_to</span><span class="p">(</span><span class="nb">max</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">count</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count_down_from</span><span class="p">(</span><span class="nb">max</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield from</span> <span class="n">count_up_to</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="nb">max</span>
</span></span><span class="line"><span class="cl">        <span class="nb">max</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span> <span class="o">=</span> <span class="n">count_down_from</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Outputs: 1, 2, 3, 3, 2, 1</span>
</span></span></code></pre></div><p>This example demonstrates using <code>yield</code> from to delegate the counting up part to another generator, which the <code>count_down_from</code> function then extends to count back down. The <code>yield</code> from expression is used in Python generators to delegate part of its operation to another generator. This provides a way to compose generators together, allowing one generator to <code>yield</code> all values from another generator before continuing with its own execution.</p>
<p>In the <code>count_down_from</code> function, <code>yield</code> from is used to incorporate all the values from the <code>count_up_to</code> generator into the <code>count_down_from</code> generator. Here&rsquo;s what happens step-by-step:</p>
<ol>
<li>Execution of <code>count_up_to</code>: When <code>count_down_from</code> reaches the line with <code>yield</code> from <code>count_up_to</code>(max), it starts executing the <code>count_up_to</code> generator.</li>
<li>Yielding from <code>count_up_to</code>: The <code>count_up_to</code> generator begins to yield values from 1 up to the maximum value (max). Each value yielded by <code>count_up_to</code> is passed directly to the caller of <code>count_down_from—as</code> if <code>count_down_from</code> were yielding these values itself.</li>
<li>Completion of <code>count_up_to</code>: Once <code>count_up_to</code> has yielded all its values and completes, control returns to <code>count_down_from</code>. Importantly, <code>count_up_to</code> needs to complete all its yields (i.e., it has to exhaust all its values by reaching its own end) before <code>count_down_from</code> continues beyond the <code>yield</code> from expression.</li>
<li>Continuation of <code>count_down_from</code>: After <code>count_up_to</code> finishes, <code>count_down_from</code> resumes execution immediately after the <code>yield</code> from line. It then proceeds to <code>yield</code> its own values, counting down from max to 1.</li>
</ol>
<p>Generators can be effectively used to build data pipelines where each generator processes some data and passes it on to the next generator in the pipeline. This modular approach can lead to clean and manageable code, particularly suitable for data transformations and filtering.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">read_logs</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Read a log file line by line.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">filter_errors</span><span class="p">(</span><span class="n">log_lines</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Yield only error messages.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">log_lines</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="s2">&#34;ERROR&#34;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield</span> <span class="n">line</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_errors</span><span class="p">(</span><span class="n">errors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Print each error line.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Build the pipeline</span>
</span></span><span class="line"><span class="cl"><span class="n">log_path</span> <span class="o">=</span> <span class="s1">&#39;server_logs.txt&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">log_lines</span> <span class="o">=</span> <span class="n">read_logs</span><span class="p">(</span><span class="n">log_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">error_lines</span> <span class="o">=</span> <span class="n">filter_errors</span><span class="p">(</span><span class="n">log_lines</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print_errors</span><span class="p">(</span><span class="n">error_lines</span><span class="p">)</span>
</span></span></code></pre></div><p>This example illustrates how a data pipeline can be constructed using generators, with each function handling a specific part of the data processing, resulting in a clear and efficient workflow.</p>
<h2 id="practicle-applications-and-examples">Practicle Applications and Examples<a hidden class="anchor" aria-hidden="true" href="#practicle-applications-and-examples">#</a></h2>
<p>Generators are ideal for searching through data and applying filters without needing to load the entire dataset into memory. This can be particularly useful in scenarios where you are working with large amounts of data that are too big to fit into memory or when you want to apply complex filters progressively.</p>
<p>Suppose you have a large log file and you need to find all entries that contain a specific error code. A generator can be used to yield only the lines that meet this criterion:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">filter_logs</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">error_code</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Generator that yields log lines containing a specific error code.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">error_code</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage</span>
</span></span><span class="line"><span class="cl"><span class="n">error_entries</span> <span class="o">=</span> <span class="n">filter_logs</span><span class="p">(</span><span class="s1">&#39;system_logs.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;Error 404&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">error_entries</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
</span></span></code></pre></div><p>In this example, the generator filter_logs reads the log file line by line, yielding only the lines that contain the specified error_code. This approach ensures that memory usage is minimal since only one line is held in memory at a time.</p>
<p>Reading large files is another practical application for generators, allowing for efficient processing of each line without the need for loading the entire file content into memory. This method is especially beneficial for handling large datasets, logs, or any large text files.</p>
<p>Imagine you have a large file containing financial transaction records, and you need to process each transaction to compute the total or apply some other analysis:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">read_transactions</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Generator that yields each transaction from a file.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">next</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>  <span class="c1"># Skip the header line if there is one</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">data</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">transaction</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;amount&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield</span> <span class="n">transaction</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Usage</span>
</span></span><span class="line"><span class="cl"><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">transactions</span> <span class="o">=</span> <span class="n">read_transactions</span><span class="p">(</span><span class="s1">&#39;transactions.csv&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">total</span> <span class="o">+=</span> <span class="n">transaction</span><span class="p">[</span><span class="s1">&#39;amount&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Total amount of transactions: $</span><span class="si">{</span><span class="n">total</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>In this example, the generator read_transactions reads a CSV file containing transaction records. It processes each line individually to extract transaction details and yields a dictionary representing each transaction. This allows you to handle the processing of each record on-the-fly and compute the total amount incrementally.</p>
<h2 id="common-practices-and-anti-patterns">Common Practices and Anti-Patterns<a hidden class="anchor" aria-hidden="true" href="#common-practices-and-anti-patterns">#</a></h2>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="performance-considerations">Performance Considerations<a hidden class="anchor" aria-hidden="true" href="#performance-considerations">#</a></h2>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/mastering_docker_swarm_pt._1/">
    <span class="title">« Prev</span>
    <br>
    <span>Mastering Docker Swarm Pt.1</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/pythondecorators/">
    <span class="title">Next »</span>
    <br>
    <span>Decorators in Python</span>
  </a>
</nav>

  </footer>
</article>


    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Francisco Mendonca&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
