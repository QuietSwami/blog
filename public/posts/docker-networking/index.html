<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Quick Docker Networking Tutorial | Francisco Mendonca&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.
Docker Bridge Networks
In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host&rsquo;s networks—and the outside world.">
<meta name="author" content="Francisco Mendonca">
<link rel="canonical" href="http://localhost:1313/posts/docker-networking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/docker-networking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Quick Docker Networking Tutorial" />
<meta property="og:description" content="This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.
Docker Bridge Networks
In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host&rsquo;s networks—and the outside world." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/docker-networking/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-19T11:56:50+02:00" />
<meta property="article:modified_time" content="2024-09-19T11:56:50+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quick Docker Networking Tutorial"/>
<meta name="twitter:description" content="This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.
Docker Bridge Networks
In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host&rsquo;s networks—and the outside world."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Quick Docker Networking Tutorial",
      "item": "http://localhost:1313/posts/docker-networking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Quick Docker Networking Tutorial",
  "name": "Quick Docker Networking Tutorial",
  "description": "This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.\nDocker Bridge Networks In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host\u0026rsquo;s networks—and the outside world.\n",
  "keywords": [
    
  ],
  "articleBody": "This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.\nDocker Bridge Networks In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host’s networks—and the outside world.\nTo communicate, containers connected to a bridge network can use the container’s name as a hostname. This means if we deploy a container with the --name or -n flag, we can use the name as the URL instead of the container’s IP address. Docker handles the DNS resolution, ensuring containers can find each other by name instead of IP.\nThe isolation of the network is great, but there are times when we need to access external networks or applications running inside containers. For this purpose, we can open ports in the network using the -p or --publish flag, specifying the target port we want to open as HOST:CONTAINER.\nHowever, there’s a limitation we need to consider: Bridge networks are restricted to a single Docker host (like our local machine). This means that if you want to connect containers deployed on multiple machines, you’ll run into challenges—this is where Docker Swarm comes in.\nDocker Swarm Docker Swarm is Docker’s native clustering and orchestration tool, allowing you to manage a cluster of Docker engines as a single virtual system. It enables you to deploy and manage a multi-container application across multiple hosts, providing scalability, high availability, and load balancing.Within Swarm, you can define Docker services, which represent a long-running container or a group of containers that work together to perform a specific task. Services allow you to easily scale your application, manage replicas, and ensure consistent deployment across your cluster.\nNow, because Docker Swarm manages multiple hosts, we need a way for containers running on different hosts to communicate with each other. This is where overlay networks come into play.\nOverlay Networks Overlay networks solve this issue by creating a virtual network that spans across all the hosts in the Swarm. This allows containers attached to the same overlay network to communicate with each other, regardless of the physical host they’re running on.\nFor example, if you have a web application running on one host and a database service on another, both connected to the same overlay network, they can seamlessly communicate as if they were on the same local network.\nDue to their distributed nature, we need to find new ways to communicate. With Docker Swarm, we deploy services that can have multiple instances of the same application, complicating matters further. A service in Docker is an abstraction that defines how a group of containers should run or behave. It also provides scaling, load balancing, and other features that I’ll discuss in another post.\nIn an Overlay Network, we have two methods to communicate between containers:\nBy using the IP addresses of the container we want to target (as we can in a bridge network). By using the service name. For instance, suppose we have two services: one called web-server with 3 replicas and another called backend-server with 2 replicas. The web-server can communicate with the backend-server using something like http://backend-server:, and Docker Swarm handles load balancing between the instances of the service. When it comes to communicating between two different bridge networks, Docker doesn’t natively support cross-network communication because bridge networks are isolated from each other. However, there are ways to enable communication between containers on different bridge networks. Key approaches include:\nContainer Networking: Using a container connected to both bridge networks. Port Publishing and External Access: Using the host network as an intermediary. Custom Network Drivers: Utilizing advanced configurations like macvlan drivers. Before diving into each solution, let’s chat about why you might want to enable communication between containers on different networks. After all, Docker’s network model is designed for isolation, providing separate namespaces for containers to enhance security, reduce interference, and ensure predictable behavior. So, why break this isolation? Here are a few scenarios where cross-network communication might be necessary:\nMicroservices Architecture with Legacy Systems:\nMicroservices in different networks may need to connect with legacy systems. Cross-network communication enables integration while maintaining isolation.\nComplex Application Segmentation:\nSegmenting application components into different networks improves organization. Controlled communication ensures they still function together.\nEnhanced Security and Compliance:\nIsolating sensitive services in secure networks ensures compliance. Controlled interaction allows functionality without compromising security.\nMulti-Host and Hybrid Deployment:\nDistributed applications across multiple hosts or cloud/on-prem setups may need to connect. Bridging networks enables unified communication across environments.\nService Discovery Challenges:\nDifferent stages or services in isolated networks can complicate discovery. Cross-network communication ensures access to shared resources or services.\nContainer Networking Let’s start with a solution by creating two separate bridge networks. We’ll place one container on each network and use a third container connected to both networks as a communication channel or “gateway.” This container will facilitate communication between the two isolated networks.\nMessaging Queues Messaging queues are communication mechanisms used to exchange data between services, applications, or components in a decoupled and asynchronous way. Think of it like a newsletter. You have a producer—someone who publishes the newsletter—and a consumer—the person who receives it. The queue is similar to the mailing list, where the newsletter is stored until all the recipients retrieve and read it. Like with a newsletter, you can have several consumers who can receive and read the messages at different times. Each subscriber (consumer) consumes the content independently. Unlike traditional newsletters, you can also have multiple producers to the same queue.\nIn a messaging queue system, consumers may acknowledge receipt of messages, and the queue can ensure that messages are delivered exactly once or at least once per consumer.\nFor this example, we’ll use RabbitMQ, but there are several commonly used messaging queues such as Apache Kafka, ActiveMQ, Mosquitto (similar, not really a messaging queue, but a message broker), and of course solutions by your favorite hyperscaler (AWS, Azure, and the like).\nStep 0: The Program We’ll deploy a program that sends and receives messages on a message queue. The idea is to deploy the same program on both networks and automatically send messages between the networks using the message broker.\nimport pika import time import random import os # Set up logging logging.basicConfig(level=logging.INFO) # Set up connection parameters rabbitmq_host = os.getenv('RABBITMQ_HOST') # RabbitMQ container name # Check if the RabbitMQ host is set if not rabbitmq_host: logging.error(\"RABBITMQ_HOST environment variable is not set\") exit(1) connection_params = pika.ConnectionParameters(host=rabbitmq_host) # Function to send messages def send_message(channel, message): # Send a message back to the queue channel.basic_publish(exchange='', routing_key='test_queue', body=message) print(f\" [x] Sent '{message}'\") # Function to handle received messages and send a response def on_message_received(ch, method, properties, body): received_message = body.decode() print(f\" [x] Received '{received_message}'\") # Create a response message response_message = f\"Response to '{received_message}' from {random.randint(1, 1000)}\" # Simulate some processing time time.sleep(2) # Send the response message send_message(ch, response_message) # Function to start the auto-messaging system def start_auto_messaging(start_with_message): # Set up a connection and channel connection = pika.BlockingConnection(connection_params) channel = connection.channel() # Declare a queue channel.queue_declare(queue='test_queue') # Check if the system should start by sending a message if start_with_message: initial_message = f\"Initial message from {random.randint(1, 1000)}\" send_message(channel, initial_message) # Start consuming and handle each message with the on_message_received function channel.basic_consume(queue='test_queue', on_message_callback=on_message_received, auto_ack=True) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': # Read environment variable to check if the system should start by sending a message start_with_message = os.getenv('START_WITH_MESSAGE', 'false').lower() == 'true' # Start the auto-messaging system start_auto_messaging(start_with_message) The application is simple: it receives two environmental variables—one to check if it should start communicating and the other with the name of the RabbitMQ container (in this case, RabbitMQ) with the messaging queue. If the application starts communicating, it sends a message with a random integer. Then, the second container will receive and send back a message composed of the message received and a new random integer.\nNote: There’s a slight bug in the app. You’ll see that the container sending the message is also able to read its own message. This can be avoided by using an app ID and setting it as a property of the message:\nchannel.basic_publish(exchange='', routing_key='test_queue', body=message, properties=pika.BasicProperties( app_id=app_id )) Then you can read the message properties and choose to only process the messages where the app ID isn’t the same as the application.\nI’ve tried to apply this, but there are some timing issues, which lead to both containers stopping sending messages. When I don’t check the app ID, the timing of the messages aligns, as the second container sends two messages in a row, allowing the first container to receive a message and continue the ping-pong process of messages. If you have a solution for this problem, please feel free to reach out!\nStep 1: Setup the Networks To start, let’s create the bridge networks. Remember, you can always do the same thing using Docker Compose.\ndocker network create bridge-net-1 docker network create bridge-net-2 To check if the networks were created\ncorrectly, run:\ndocker network ls The output should look something like this:\nNETWORK ID NAME DRIVER SCOPE 217ae951f2e2 bridge bridge local ece230c416f2 bridge-net-1 bridge local 34d8e1e02ae2 bridge-net-2 bridge local d068772975fd host host local 8bc70472ebe1 none null local Step 2: Deploy Containers on Each Network Next, we’ll deploy the RabbitMQ container:\ndocker run -d --name rabbitmq --network bridge-net-1 --network bridge-net-2 rabbitmq Once RabbitMQ is deployed and running, we can deploy the same container on each of the networks:\ndocker run -d --name app1 --network bridge-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker run -d --name app2 --network bridge-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Once both containers are running, we can check the logs to see that the messages are being passed correctly, even if the containers are in separate networks. The RabbitMQ container, which is attached to both networks, can receive messages from both networks and pass them to the opposite network from which the message was sent.\nI’ve also written a Docker Compose file to make the deployment of the application simpler.\nOverlay Networks While overlay networks span across different hosts, the same process can be used. You can create two overlay networks, attach one container to both, and use that container as a communication channel between the networks. The only difference is in network creation, where you would specify the overlay type.\ndocker network create -d overlay overlay-net-1 docker network create -d overlay overlay-net-2 If you attempt to create these networks, you might encounter the following error:\nError response from daemon: This node is not a swarm manager. Use \"docker swarm init\" or \"docker swarm join\" to connect this node to swarm and try again. Overlay networks are Swarm-specific networks and can only be created by the manager of the swarm.\nTo test this locally, initialize a Swarm with docker swarm init, create the two networks, and launch the application as a stack of services.\nFirst, deploy RabbitMQ as a service:\ndocker service create --name rabbitmq --network overlay-net-1 --network overlay-net-2 --replicas 1 rabbitmq:latest Notice that we aren’t publishing any ports, as we aren’t trying to access the RabbitMQ instance from outside of both networks. Without publishing ports, only the containers connected to the network can communicate with the service.\nNow, let’s deploy our services:\ndocker service create --name app1 --network overlay-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker service create --name app2 --network overlay-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Then, we can check the logs by running:\ndocker service logs app1 You should see messages coming and going from RabbitMQ between the services deployed in two different overlay networks.\nPort Publishing and External Access In certain cases, we might need to communicate with services running outside of our networks. For this, we need to publish ports for the containers that will communicate. This opens these ports to the world—anyone who knows that the port is open can attempt to communicate with our services. This capability is essential for applications that need to be accessed by users or other systems outside of the Docker environment, such as web applications, APIs, or databases.\nHow Port Publishing Works When you publish a port, you map a port from the container to a port on the host machine. This allows traffic sent to the host’s specified port to be routed to the corresponding port on the container. For instance, if you have a web application running in a container on port 80, you can expose it to the outside world by mapping it to a port on the host, such as port 8080.\ndocker service create \\ --name my-web-app \\ --publish published=8080,target=80 \\ my-web-app-image While port publishing is a powerful feature, it also introduces security considerations:\nOpen Ports: When you expose a port, it becomes accessible to anyone who knows the host’s IP address and the port number. It’s crucial to implement proper security measures. Secure Protocols: Always prefer secure protocols, such as HTTPS, when exposing services to the public. Rate Limiting: If you’re exposing a port, consider implementing throttling mechanisms to prevent abuse of your services. Port publishing is a critical part of using Docker, even when you’re working with Docker networks. Many services we want to expose require access from various locations. If you want to know more about how to use Swarm effectively, I’ve started a series on [Mastering Docker Swarm]({{ \u003c ref “Mastering_Docker_Swarm_Pt._1”\u003e }}).\nCustom Network Drivers While Bridge and Overlay networks are great out-of-the-box, there are situations where these won’t suffice. For this, Docker provides a way to build custom network drivers, which can be tailored to suit specific application requirements. This allows for greater flexibility in configuring networks.\nThe reasons for using custom drivers might differ. One clear use case is when you need support for specific, non-standard protocols (instead of HTTP, think multicast or specifying MTU sizes). Another case is when you need to integrate with existing enterprise networks, or better yet, with legacy systems.\nAnother good reason might be the need for enhanced performance. For high-performance applications requiring real-time data processing, a custom network driver can help you tune network parameters, leading to improvements in data transfer rates or reduced latency.\nAlso, by creating a custom network driver, you can incorporate advanced security features to enhance isolation and encryption of your data.\nAs you can see here, several network drivers have already been developed that could be used in your next project. These drivers add various tools on top of the default networks, from enhanced logging and monitoring capabilities to support for more complex routing policies.\nConclusion Custom network drivers are an essential part of Docker networking, providing the flexibility needed to address specific challenges in modern applications. By understanding when and how to use these drivers, you can optimize container networking for performance, security, and compatibility with existing infrastructure. Whether you choose to leverage existing solutions or develop your own, custom network drivers can significantly enhance the functionality of your containerized applications.\n",
  "wordCount" : "2513",
  "inLanguage": "en",
  "datePublished": "2024-09-19T11:56:50+02:00",
  "dateModified": "2024-09-19T11:56:50+02:00",
  "author":{
    "@type": "Person",
    "name": "Francisco Mendonca"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/docker-networking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Francisco Mendonca's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Francisco Mendonca&#39;s Blog (Alt + H)">Francisco Mendonca&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Quick Docker Networking Tutorial
    </h1>
    <div class="post-meta"><span title='2024-09-19 11:56:50 +0200 CEST'>September 19, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Francisco Mendonca

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#docker-bridge-networks" aria-label="Docker Bridge Networks">Docker Bridge Networks</a></li>
                <li>
                    <a href="#docker-swarm" aria-label="Docker Swarm">Docker Swarm</a></li>
                <li>
                    <a href="#overlay-networks" aria-label="Overlay Networks">Overlay Networks</a></li>
                <li>
                    <a href="#container-networking" aria-label="Container Networking">Container Networking</a><ul>
                        
                <li>
                    <a href="#messaging-queues" aria-label="Messaging Queues">Messaging Queues</a></li>
                <li>
                    <a href="#step-0-the-program" aria-label="Step 0: The Program">Step 0: The Program</a></li>
                <li>
                    <a href="#step-1-setup-the-networks" aria-label="Step 1: Setup the Networks">Step 1: Setup the Networks</a></li>
                <li>
                    <a href="#step-2-deploy-containers-on-each-network" aria-label="Step 2: Deploy Containers on Each Network">Step 2: Deploy Containers on Each Network</a></li>
                <li>
                    <a href="#overlay-networks-1" aria-label="Overlay Networks">Overlay Networks</a></li></ul>
                </li>
                <li>
                    <a href="#port-publishing-and-external-access" aria-label="Port Publishing and External Access">Port Publishing and External Access</a><ul>
                        
                <li>
                    <a href="#how-port-publishing-works" aria-label="How Port Publishing Works">How Port Publishing Works</a></li></ul>
                </li>
                <li>
                    <a href="#custom-network-drivers" aria-label="Custom Network Drivers">Custom Network Drivers</a><ul>
                        
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This tutorial focuses on two of the many networks Docker offers: Bridge and Overlay. These networks serve similar purposes in different scenarios.</p>
<h2 id="docker-bridge-networks">Docker Bridge Networks<a hidden class="anchor" aria-hidden="true" href="#docker-bridge-networks">#</a></h2>
<p>In Docker, a Bridge Network is the default. If no network is specified when deploying a container, Docker assumes it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the host&rsquo;s networks—and the outside world.</p>
<p><img loading="lazy" src="images/docker-bridge-net.png" alt="Docker Bridge Network"  />
</p>
<p>To communicate, containers connected to a bridge network can use the container&rsquo;s name as a hostname. This means if we deploy a container with the <code>--name</code> or <code>-n</code> flag, we can use the name as the URL instead of the container&rsquo;s IP address. Docker handles the DNS resolution, ensuring containers can find each other by name instead of IP.</p>
<p>The isolation of the network is great, but there are times when we need to access external networks or applications running inside containers. For this purpose, we can open ports in the network using the <code>-p</code> or <code>--publish</code> flag, specifying the target port we want to open as <code>HOST:CONTAINER</code>.</p>
<p>However, there’s a limitation we need to consider: Bridge networks are restricted to a single Docker host (like our local machine). This means that if you want to connect containers deployed on multiple machines, you&rsquo;ll run into challenges—this is where Docker Swarm comes in.</p>
<h2 id="docker-swarm">Docker Swarm<a hidden class="anchor" aria-hidden="true" href="#docker-swarm">#</a></h2>
<p>Docker Swarm is Docker’s native clustering and orchestration tool, allowing you to manage a cluster of Docker engines as a single virtual system. It enables you to deploy and manage a multi-container application across multiple hosts, providing scalability, high availability, and load balancing.Within Swarm, you can define Docker services, which represent a long-running container or a group of containers that work together to perform a specific task. Services allow you to easily scale your application, manage replicas, and ensure consistent deployment across your cluster.</p>
<p><img loading="lazy" src="images/docker-swarm-service.png" alt="How services work on Docker Swarm"  />
</p>
<p>Now, because Docker Swarm manages multiple hosts, we need a way for containers running on different hosts to communicate with each other. This is where overlay networks come into play.</p>
<h2 id="overlay-networks">Overlay Networks<a hidden class="anchor" aria-hidden="true" href="#overlay-networks">#</a></h2>
<p>Overlay networks solve this issue by creating a virtual network that spans across all the hosts in the Swarm. This allows containers attached to the same overlay network to communicate with each other, regardless of the physical host they’re running on.</p>
<p><img loading="lazy" src="images/docker-overlay-net.png" alt="Overlay Network"  />
</p>
<p>For example, if you have a web application running on one host and a database service on another, both connected to the same overlay network, they can seamlessly communicate as if they were on the same local network.</p>
<p>Due to their distributed nature, we need to find new ways to communicate. With Docker Swarm, we deploy services that can have multiple instances of the same application, complicating matters further. A service in Docker is an abstraction that defines how a group of containers should run or behave. It also provides scaling, load balancing, and other features that I&rsquo;ll discuss in another post.</p>
<p>In an Overlay Network, we have two methods to communicate between containers:</p>
<ol>
<li>By using the IP addresses of the container we want to target (as we can in a bridge network).</li>
<li>By using the <em>service</em> name. For instance, suppose we have two services: one called <code>web-server</code> with 3 replicas and another called <code>backend-server</code> with 2 replicas. The <code>web-server</code> can communicate with the <code>backend-server</code> using something like <code>http://backend-server:&lt;PORT&gt;</code>, and Docker Swarm handles load balancing between the instances of the service.</li>
</ol>
<p>When it comes to communicating between two different bridge networks, Docker doesn’t natively support cross-network communication because bridge networks are isolated from each other. However, there are ways to enable communication between containers on different bridge networks. Key approaches include:</p>
<ol>
<li><strong>Container Networking</strong>: Using a container connected to both bridge networks.</li>
<li><strong>Port Publishing and External Access</strong>: Using the host network as an intermediary.</li>
<li><strong>Custom Network Drivers</strong>: Utilizing advanced configurations like macvlan drivers.</li>
</ol>
<p>Before diving into each solution, let&rsquo;s chat about why you might want to enable communication between containers on different networks. After all, Docker’s network model is designed for isolation, providing separate namespaces for containers to enhance security, reduce interference, and ensure predictable behavior. So, why break this isolation? Here are a few scenarios where cross-network communication might be necessary:</p>
<ol>
<li>
<p><strong>Microservices Architecture with Legacy Systems</strong>:<br>
Microservices in different networks may need to connect with legacy systems. Cross-network communication enables integration while maintaining isolation.</p>
</li>
<li>
<p><strong>Complex Application Segmentation</strong>:<br>
Segmenting application components into different networks improves organization. Controlled communication ensures they still function together.</p>
</li>
<li>
<p><strong>Enhanced Security and Compliance</strong>:<br>
Isolating sensitive services in secure networks ensures compliance. Controlled interaction allows functionality without compromising security.</p>
</li>
<li>
<p><strong>Multi-Host and Hybrid Deployment</strong>:<br>
Distributed applications across multiple hosts or cloud/on-prem setups may need to connect. Bridging networks enables unified communication across environments.</p>
</li>
<li>
<p><strong>Service Discovery Challenges</strong>:<br>
Different stages or services in isolated networks can complicate discovery. Cross-network communication ensures access to shared resources or services.</p>
</li>
</ol>
<h2 id="container-networking">Container Networking<a hidden class="anchor" aria-hidden="true" href="#container-networking">#</a></h2>
<p>Let’s start with a solution by creating two separate bridge networks. We&rsquo;ll place one container on each network and use a third container connected to both networks as a communication channel or &ldquo;gateway.&rdquo; This container will facilitate communication between the two isolated networks.</p>
<p><img loading="lazy" src="images/docker-bridge-exercise.png" alt="Communication Between Networks"  />
</p>
<h3 id="messaging-queues">Messaging Queues<a hidden class="anchor" aria-hidden="true" href="#messaging-queues">#</a></h3>
<p>Messaging queues are communication mechanisms used to exchange data between services, applications, or components in a decoupled and asynchronous way. Think of it like a newsletter. You have a producer—someone who publishes the newsletter—and a consumer—the person who receives it. The queue is similar to the mailing list, where the newsletter is stored until all the recipients retrieve and read it. Like with a newsletter, you can have several consumers who can receive and read the messages at different times. Each subscriber (consumer) consumes the content independently. Unlike traditional newsletters, you can also have multiple producers to the same queue.</p>
<p>In a messaging queue system, consumers may acknowledge receipt of messages, and the queue can ensure that messages are delivered exactly once or at least once per consumer.</p>
<p>For this example, we&rsquo;ll use <a href="https://www.rabbitmq.com">RabbitMQ</a>, but there are several commonly used messaging queues such as <a href="https://kafka.apache.org">Apache Kafka</a>, <a href="https://activemq.apache.org">ActiveMQ</a>, <a href="https://mosquitto.org">Mosquitto</a> (similar, not really a messaging queue, but a message broker), and of course solutions by your favorite hyperscaler (AWS, Azure, and the like).</p>
<h3 id="step-0-the-program">Step 0: The Program<a hidden class="anchor" aria-hidden="true" href="#step-0-the-program">#</a></h3>
<p>We&rsquo;ll deploy a program that sends and receives messages on a message queue. The idea is to deploy the same program on both networks and automatically send messages between the networks using the message broker.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pika</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set up logging</span>
</span></span><span class="line"><span class="cl"><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set up connection parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">rabbitmq_host</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;RABBITMQ_HOST&#39;</span><span class="p">)</span>  <span class="c1"># RabbitMQ container name </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Check if the RabbitMQ host is set</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">rabbitmq_host</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&#34;RABBITMQ_HOST environment variable is not set&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">connection_params</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">rabbitmq_host</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to send messages</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">send_message</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Send a message back to the queue</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">basic_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">body</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34; [x] Sent &#39;</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&#39;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to handle received messages and send a response</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">on_message_received</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">received_message</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34; [x] Received &#39;</span><span class="si">{</span><span class="n">received_message</span><span class="si">}</span><span class="s2">&#39;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Create a response message</span>
</span></span><span class="line"><span class="cl">    <span class="n">response_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Response to &#39;</span><span class="si">{</span><span class="n">received_message</span><span class="si">}</span><span class="s2">&#39; from </span><span class="si">{</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Simulate some processing time</span>
</span></span><span class="line"><span class="cl">    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Send the response message</span>
</span></span><span class="line"><span class="cl">    <span class="n">send_message</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">response_message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to start the auto-messaging system</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">start_auto_messaging</span><span class="p">(</span><span class="n">start_with_message</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Set up a connection and channel</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">BlockingConnection</span><span class="p">(</span><span class="n">connection_params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Declare a queue</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the system should start by sending a message</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">start_with_message</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">initial_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Initial message from </span><span class="si">{</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">send_message</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">initial_message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Start consuming and handle each message with the on_message_received function</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">basic_consume</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">on_message_callback</span><span class="o">=</span><span class="n">on_message_received</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">auto_ack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; [*] Waiting for messages. To exit press CTRL+C&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">start_consuming</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Read environment variable to check if the system should start by sending a message</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_with_message</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;START_WITH_MESSAGE&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Start the auto-messaging system</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_auto_messaging</span><span class="p">(</span><span class="n">start_with_message</span><span class="p">)</span>
</span></span></code></pre></div><p>The application is simple: it receives two environmental variables—one to check if it should start communicating and the other with the name of the RabbitMQ container (in this case, RabbitMQ) with the messaging queue. If the application starts communicating, it sends a message with a random integer. Then, the second container will receive and send back a message composed of the message received and a new random integer.</p>
<p><strong>Note</strong>: There&rsquo;s a slight bug in the app. You’ll see that the container sending the message is also able to read its own message. This can be avoided by using an app ID and setting it as a property of the message:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">channel</span><span class="o">.</span><span class="n">basic_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">body</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">properties</span><span class="o">=</span><span class="n">pika</span><span class="o">.</span><span class="n">BasicProperties</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                          <span class="n">app_id</span><span class="o">=</span><span class="n">app_id</span>
</span></span><span class="line"><span class="cl">                    <span class="p">))</span>
</span></span></code></pre></div><p>Then you can read the message properties and choose to only process the messages where the app ID isn&rsquo;t the same as the application.</p>
<p>I&rsquo;ve tried to apply this, but there are some timing issues, which lead to both containers stopping sending messages. When I don&rsquo;t check the app ID, the timing of the messages aligns, as the second container sends two messages in a row, allowing the first container to receive a message and continue the ping-pong process of messages. If you have a solution for this problem, please feel free to reach out!</p>
<h3 id="step-1-setup-the-networks">Step 1: Setup the Networks<a hidden class="anchor" aria-hidden="true" href="#step-1-setup-the-networks">#</a></h3>
<p>To start, let&rsquo;s create the bridge networks. Remember, you can always do the same thing using Docker Compose.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network create bridge-net-1
</span></span><span class="line"><span class="cl">docker network create bridge-net-2
</span></span></code></pre></div><p>To check if the networks were created</p>
<p>correctly, run:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network ls
</span></span></code></pre></div><p>The output should look something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">NETWORK ID     NAME           DRIVER    SCOPE
</span></span><span class="line"><span class="cl">217ae951f2e2   bridge         bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">ece230c416f2   bridge-net-1   bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">34d8e1e02ae2   bridge-net-2   bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">d068772975fd   host           host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">8bc70472ebe1   none           null      <span class="nb">local</span>
</span></span></code></pre></div><h3 id="step-2-deploy-containers-on-each-network">Step 2: Deploy Containers on Each Network<a hidden class="anchor" aria-hidden="true" href="#step-2-deploy-containers-on-each-network">#</a></h3>
<p>Next, we&rsquo;ll deploy the RabbitMQ container:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -d --name rabbitmq --network bridge-net-1 --network bridge-net-2 rabbitmq
</span></span></code></pre></div><p>Once RabbitMQ is deployed and running, we can deploy the same container on each of the networks:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -d --name app1 --network bridge-net-1 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">true</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span><span class="line"><span class="cl">docker run -d --name app2 --network bridge-net-2 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">false</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span></code></pre></div><p>Once both containers are running, we can check the logs to see that the messages are being passed correctly, even if the containers are in separate networks. The RabbitMQ container, which is attached to both networks, can receive messages from both networks and pass them to the opposite network from which the message was sent.</p>
<p><a href="https://github.com/QuietSwami/docker-network-example/blob/main/container-networking/docker-compose.yaml">I&rsquo;ve also written a Docker Compose file to make the deployment of the application simpler</a>.</p>
<h3 id="overlay-networks-1">Overlay Networks<a hidden class="anchor" aria-hidden="true" href="#overlay-networks-1">#</a></h3>
<p>While overlay networks span across different hosts, the same process can be used. You can create two overlay networks, attach one container to both, and use that container as a communication channel between the networks. The only difference is in network creation, where you would specify the overlay type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network create -d overlay overlay-net-1
</span></span><span class="line"><span class="cl">docker network create -d overlay overlay-net-2
</span></span></code></pre></div><p>If you attempt to create these networks, you might encounter the following error:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Error response from daemon: This node is not a swarm manager. Use <span class="s2">&#34;docker swarm init&#34;</span> or <span class="s2">&#34;docker swarm join&#34;</span> to connect this node to swarm and try again.
</span></span></code></pre></div><p>Overlay networks are Swarm-specific networks and can only be created by the manager of the swarm.</p>
<p>To test this locally, initialize a Swarm with <code>docker swarm init</code>, create the two networks, and launch the application as a stack of services.</p>
<p>First, deploy RabbitMQ as a service:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create --name rabbitmq --network overlay-net-1 --network overlay-net-2 --replicas <span class="m">1</span> rabbitmq:latest
</span></span></code></pre></div><p>Notice that we aren&rsquo;t publishing any ports, as we aren&rsquo;t trying to access the RabbitMQ instance from outside of both networks. Without publishing ports, only the containers connected to the network can communicate with the service.</p>
<p>Now, let&rsquo;s deploy our services:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create --name app1 --network overlay-net-1 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">true</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span><span class="line"><span class="cl">docker service create --name app2 --network overlay-net-2 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">false</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span></code></pre></div><p>Then, we can check the logs by running:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service logs app1
</span></span></code></pre></div><p>You should see messages coming and going from RabbitMQ between the services deployed in two different overlay networks.</p>
<h2 id="port-publishing-and-external-access">Port Publishing and External Access<a hidden class="anchor" aria-hidden="true" href="#port-publishing-and-external-access">#</a></h2>
<p>In certain cases, we might need to communicate with services running outside of our networks. For this, we need to publish ports for the containers that will communicate. This opens these ports to the world—anyone who knows that the port is open can attempt to communicate with our services. This capability is essential for applications that need to be accessed by users or other systems outside of the Docker environment, such as web applications, APIs, or databases.</p>
<h3 id="how-port-publishing-works">How Port Publishing Works<a hidden class="anchor" aria-hidden="true" href="#how-port-publishing-works">#</a></h3>
<p>When you publish a port, you map a port from the container to a port on the host machine. This allows traffic sent to the host&rsquo;s specified port to be routed to the corresponding port on the container. For instance, if you have a web application running in a container on port 80, you can expose it to the outside world by mapping it to a port on the host, such as port 8080.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --name my-web-app <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --publish <span class="nv">published</span><span class="o">=</span>8080,target<span class="o">=</span><span class="m">80</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  my-web-app-image
</span></span></code></pre></div><p>While port publishing is a powerful feature, it also introduces security considerations:</p>
<ol>
<li><strong>Open Ports</strong>: When you expose a port, it becomes accessible to anyone who knows the host&rsquo;s IP address and the port number. It’s crucial to implement proper security measures.</li>
<li><strong>Secure Protocols</strong>: Always prefer secure protocols, such as HTTPS, when exposing services to the public.</li>
<li><strong>Rate Limiting</strong>: If you’re exposing a port, consider implementing throttling mechanisms to prevent abuse of your services.</li>
</ol>
<p>Port publishing is a critical part of using Docker, even when you&rsquo;re working with Docker networks. Many services we want to expose require access from various locations. If you want to know more about how to use Swarm effectively, I&rsquo;ve started a series on [Mastering Docker Swarm]({{ &lt; ref &ldquo;Mastering_Docker_Swarm_Pt._1&rdquo;&gt; }}).</p>
<h2 id="custom-network-drivers">Custom Network Drivers<a hidden class="anchor" aria-hidden="true" href="#custom-network-drivers">#</a></h2>
<p>While Bridge and Overlay networks are great out-of-the-box, there are situations where these won&rsquo;t suffice. For this, Docker provides a way to build <em>custom network drivers</em>, which can be tailored to suit specific application requirements. This allows for greater flexibility in configuring networks.</p>
<p>The reasons for using custom drivers might differ. One clear use case is when you need support for specific, non-standard protocols (instead of HTTP, think multicast or specifying MTU sizes). Another case is when you need to integrate with existing enterprise networks, or better yet, with legacy systems.</p>
<p>Another good reason might be the need for enhanced performance. For high-performance applications requiring real-time data processing, a custom network driver can help you tune network parameters, leading to improvements in data transfer rates or reduced latency.</p>
<p>Also, by creating a custom network driver, you can incorporate advanced security features to enhance isolation and encryption of your data.</p>
<p>As you can see <a href="https://github.com/veggiemonk/awesome-docker?tab=readme-ov-file#networking">here</a>, several network drivers have already been developed that could be used in your next project. These drivers add various tools on top of the default networks, from enhanced logging and monitoring capabilities to support for more complex routing policies.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Custom network drivers are an essential part of Docker networking, providing the flexibility needed to address specific challenges in modern applications. By understanding when and how to use these drivers, you can optimize container networking for performance, security, and compatibility with existing infrastructure. Whether you choose to leverage existing solutions or develop your own, custom network drivers can significantly enhance the functionality of your containerized applications.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/federation/">
    <span class="title">Next »</span>
    <br>
    <span>Federation</span>
  </a>
</nav>

  </footer>
</article>


    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Francisco Mendonca&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
