<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Quick Docker Networking Tutorial | Francisco Mendonca&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.
In Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.">
<meta name="author" content="Francisco Mendonca">
<link rel="canonical" href="http://localhost:1313/posts/docker-networking/dockernetworking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/docker-networking/dockernetworking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Quick Docker Networking Tutorial" />
<meta property="og:description" content="This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.
In Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/docker-networking/dockernetworking/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-19T11:56:50+02:00" />
<meta property="article:modified_time" content="2024-09-19T11:56:50+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quick Docker Networking Tutorial"/>
<meta name="twitter:description" content="This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.
In Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Quick Docker Networking Tutorial",
      "item": "http://localhost:1313/posts/docker-networking/dockernetworking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Quick Docker Networking Tutorial",
  "name": "Quick Docker Networking Tutorial",
  "description": "This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.\nIn Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.\n",
  "keywords": [
    
  ],
  "articleBody": "This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.\nIn Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.\nTo communicate, containers connected to a bridge network can communicate using the container’s name as hostname. This means that, if we deploy a container by specifying the flag --name or -n, to communicate we can use the name given to the container as the URL, instead of having to use the container’s IP address in the network. Docker allows this by internally handling the DNS resolution of these names, to ensure that containers can find each other using known names and not IPs.\nThe isolation of the network is great and all but sometimes we need to access external networks, or at least, we might need to be able to access the application running inside of the container. For this we can open ports in the network by using the flag -p or --publish, and specifying the target port we want to open HOST:CONTAINER.\nHaving now understood how Bridge networks work, another problem arises. Bridge networks are limited to a single Docker Host (let’s say, our local machine). Therefore, there is no way of connecting containers deployed in serveral machines, as we normally want to do when we use Docker Swarm.\nOverlay networks solve this issue by creating a distributed network across multiple hosts (this is done using a combination of tunneling and encryption, but this is a bit hard to explain here). This creates a network where all containers attached to the network are able to communicate, even if they are running in different hosts.\nNow, due to their distributed nature, we need to find a new way to communicate. Also, with Docker Swarm, we are deploying services which can have several instances of the same application, thus complicating matters. A service in Docker is an abstraction to define how a group of containers (one or more) should run or behave. It also provides scalling, load balancing, and other things which I’ll get to in another post.\nSo, in an Overlay Network we have two methods to communicate between containers. The first is by using the IP addresses of the container we wish to target (as we already could in a bridge network). The second is to communicate using the service name. Let’s supose that we have two services, one called web-server with 3 replicas, and the other called backend-server with 2 replicas. For the web-service to communicate with the backend-service it can use something like http://backend-service:, and the rest of the work is done by Swarm, like the load balancing between the instances of the service.\nWhen it comes to communicating between two different bridge networks, Docker doesn’t natively support cross-network communication out of the box because bridge networks are isolated from each other. However, there are ways to enable communication between containers on different bridge networks. The key approaches involve routing traffic between the networks using either:\nContainer Networking: A container connected to both bridge networks. Port Publishing and External Access: Using the host network as an intermediary. Custom Network Drivers: Using more advanced configurations like macvlan drivers. Before going through each one of the solutions, let’s have a quick chat about why you would want to enable communication between containers on different networks. After all, Docker’s network model is designed with isolation in mind, providing separate namespaces for containers to enhance security, reduce interference, and ensure predictable behavior. So, why break this isolation? Here are a few scenarios where cross-network communication might be necessary:\nMicroservices Architecture with Legacy Systems:\nMicroservices in different networks may need to connect with legacy systems. Cross-network communication enables integration while maintaining isolation.\nComplex Application Segmentation:\nSegmenting application components into different networks improves organization. Controlled communication ensures they still function together.\nEnhanced Security and Compliance:\nIsolating sensitive services in secure networks ensures compliance. Controlled interaction allows functionality without compromising security.\nMulti-Host and Hybrid Deployment:\nDistributed applications across multiple hosts or cloud/on-prem setups may need to connect. Bridging networks enables unified communication across environments.\nService Discovery Challenges:\nDifferent stages or services in isolated networks can complicate discovery. Cross-network communication ensures access to shared resources or services.\nContainer Networking Let’s start with our solution by creating two separate bridge networks. We’ll place one container on each network and use a third container that is attached to both networks as a communication channel, or “gateway.” This container will allow the two isolated networks to communicate with each other.\nMessaging Queues Messaging queues are communication mechanisms used to exchange data between services, applications, or componenets in a decouples and asynchrounous way. Think of it like a newsletter. You have a producer - someone who publishes the newsletter; a consumer - the person who receives the newsletter; and a queue - similar to the mailing list, where the newsletter is stored untill all the recipients retrieve and read it. Like with a newsletter, in a messaging queue you can have several consummers which can receive and read the messages at different times. Each subscriber (consumer) consumes the content independently. Unlike traditional newsletters, you can also have several producers to the same queue.\nAlso, unlike newletters, in a messaging queue system, consumers may acknoledge receipt of messages, and the queue may ensure that messages are delivered exactly once or at least once per consumer.\nFor this example, we’ll use RabbitMQ, but there are several commonly used messaging queues such as Apache Kafka, ActiveMQ, Mosquitto (similar, not really a messaging queue, but a message broker), and of course solutions by your favorite hyperscaler (AWS, Azure, and the like).\nStep 0: The program We’ll deploy a program that sends and receives messages on a message queue. The idea is to deploy the same program on both networks, and send messages between the networks using the message broker. In this case, the program will do this automatically.\nimport pika import time import random import os # Set up logging logging.basicConfig(level=logging.INFO) # Set up connection parameters rabbitmq_host = os.getenv('RABBITMQ_HOST') # RabbitMQ container name # Check if the RabbitMQ host is set if not rabbitmq_host: logging.error(\"RABBITMQ_HOST environment variable is not set\") exit(1) connection_params = pika.ConnectionParameters(host=rabbitmq_host) # Function to send messages def send_message(channel, message): # Send a message back to the queue channel.basic_publish(exchange='', routing_key='test_queue', body=message) print(f\" [x] Sent '{message}'\") # Function to handle received messages and send a response def on_message_received(ch, method, properties, body): received_message = body.decode() print(f\" [x] Received '{received_message}'\") # Create a response message response_message = f\"Response to '{received_message}' from {random.randint(1, 1000)}\" # Simulate some processing time time.sleep(2) # Send the response message send_message(ch, response_message) # Function to start the auto-messaging system def start_auto_messaging(start_with_message): # Set up a connection and channel connection = pika.BlockingConnection(connection_params) channel = connection.channel() # Declare a queue channel.queue_declare(queue='test_queue') # Check if the system should start by sending a message if start_with_message: initial_message = f\"Initial message from {random.randint(1, 1000)}\" send_message(channel, initial_message) # Start consuming and handle each message with the on_message_received function channel.basic_consume(queue='test_queue', on_message_callback=on_message_received, auto_ack=True) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() if __name__ == '__main__': # Read environment variable to check if the system should start by sending a message start_with_message = os.getenv('START_WITH_MESSAGE', 'false').lower() == 'true' # Start the auto-messaging system start_auto_messaging(start_with_message) The application is simple: the application receives two environmental variable - one to check if it should start communicating, and the other with the name of the container (in this case RabbitMQ) with the messaging queue. If the application starts communicating, then it starts by sending a message with a random integer. Then, the second container will receive and send back a messgage composed of the message received and a new random integer.\nNOTE: There’s a slight bug in the app. You’ll see that the container who sends the message is also able to read it’s own message. This can be avoided by using an app ID and setting it as a property of the message\nchannel.basic_publish(exchange='', routing_key='test_queue', body=message, properties=pika.BasicProperties( app_id=app_id )) Then you can read the message properties, and select to only process the messages where the app_id isn’t the same as the application. I’ve tried to apply this, but there is some timing issues, which leads to the both containers stopping sending messages. When I don’t check the app ID, the timing of the messages aligns, as the second container sends two messages in a row, which leads to the first container receiving a message and the ping-pong process of messages starts and continues correctly. If you have a solution for this problem, please don’t hesitate to send me a message!\nStep 1: Setup the networks To start, let’s create the bridge networks. Remember, you can always do the same thing using Docker Compose.\ndocker network create bridge-net-1 docker network create bridge-net-2 To check if the networks were correctly created, run the following command:\ndocker network ls The output should be something like:\ncode-gen ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 217ae951f2e2 bridge bridge local ece230c416f2 bridge-net-1 bridge local 34d8e1e02ae2 bridge-net-2 bridge local d068772975fd host host local 8bc70472ebe1 none null local Step 2: Deploy containers on each network Next, we’ll deploy the RabbitMQ container:\ndocker run -d --name rabbitmq --network bridge-net-1 --network bridge-net-2 rabbitmq Once RabbitMQ is deployed and running, we can deploy the same container in each of the networks:\ndocker run -d --name app1 --network bridge-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker run -d --name app2 --network bridge-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Once both containers are running, we an check on the logs that the messages are being passed correctly, even if the containers are in seperate networks. The RabbitMQ container, which is attached to both networks, is able to receive messages from both networks and passed them to the opposite network from which the message was sent.\nI’ve also wrote a docker-compose file to make the deployment of the application simpler.\nOverlay Networks While overlay networks are spread across different hosts, the same process can be used. You can create two overlay networks, attach one container to both, and use that container as a communication channel between the networks. The only difference would be on network creation, where you would have to specify the overlay type.\ndocker network create -d overlay overlay-net-1 docker network create -d overlay overlay-net-2 Now, if you attempt to create these networks you might encounter the following error:\nError response from daemon: This node is not a swarm manager. Use \"docker swarm init\" or \"docker swarm join\" to connect this node to swarm and try again. Overlay networks are Swarm-specific networks, and can only be created by the manager of the swarm.\nTo test this locally let’s create a Swarm by doing docker swarm init, create the two networks, and lauch the application as a stack of services. First, let’s deploy RabbitMQ as a service:\ndocker service create --name rabbitmq --network overlay-net-1 --network overlay-net-2 --replicas 1 rabbitmq:latest Notice that we aren’t publishing any ports, as we are not trying to access the RabbitMQ instance from outside of both networks. Without publishing ports, only the containers connected to the network can communicate with the service.\nNow, let’s deploy our services:\ndocker service create --name app1 --network overlay-net-1 -e START_WITH_MESSAGE=true -e RABBITMQ_HOST=rabbitmq auto_messaging docker service create --name app2 --network overlay-net-2 -e START_WITH_MESSAGE=false -e RABBITMQ_HOST=rabbitmq auto_messaging Then, we can check the logs by:\ndocker service logs app1 You should be able to see messages comming and going from the RabbitMQ between the services deployed in two different overlay networks.\nPort Publishing and External Acess In certain cases, we might need to communicate with services running outside of your networks. For this, we need to publish ports for the containers that will communicate. In this case, we are opening these ports to the world—anyone that knows that the port is open can attempt to communicate with our services. This capability is essential for applications that need to be accessed by users or other systems outside of the Docker environment, such as web applications, APIs, or databases.\nHow Port Publishing works? When you publish a port, you map a port from the container to a port on the host machine. This allows traffic sent to the host’s specified port to be routed to the corresponding port on the container. For instance, if you have a web application running in a container on port 80, you can expose it to the outside world by mapping it to a port on the host, such as port 8080.\ndocker service create \\ --name my-web-app \\ --publish published=8080,target=80 \\ my-web-app-image While port publishing is a powerful feature, it also introduces security considerations:\nOpen Ports: When you expose a port, it becomes accessible to anyone who knows the host’s IP address and the port number. You should take this into consideration and employ proper security measures. Secure Protocols: Always prefer secure protocols, such as HTTPS, when exposing ports. Rate Limiting: If you are exposing a port, be sure to implement throttling mechanisms to prevent abuse of your services. Port publishing is a critical part of Docker use, even if you are using a Docker network. There are services that we wish to expose to be able to use them from wherever we are. If you want to know more about how to properly use Swarm, I’ve started a series on [Masetering Docker Swarm]({{ \u003c ref “Mastering_Docker_Swarm_Pt._1”\u003e}}).\nCustom Network Drivers While Bridge and Overlay networks are great out-of-the-box, there are situations where these won’t suffice. For this, Docker provides a way to build custom network drivers, which can be customized to suit specific application requirements. This allows for greater flexibility in configuring networks.\nThe reasons for the use of custom drivers might differ, one use case which seems clear is when you need support for specific, non-standard, protocols (instead of HTTP, something like multicast or specifiying MTU sizes). Another case is when we need to integrate with existing entriprise networks, and better yet, with legacy systems.\nAnother good reason might be the need for enhanced performace - let’s say for high-performance applications, where you need to process real-time data. With a custom network driver, you can tune the network paramaters, which can lead to improvements in data transfer rates or reduced latency.\nAlso, by creating a custom network driver you can incorporate advanced security features, to further enhanced isolation and encryption of your data.\nAs you can see here, there are already several network drivers developed, which could be used in you next project. These drivers add several tools on top of the default networks, from enhanced logging and monitoring capabilities to support for more complex routing policies.\nThe procedure to run a custom network driver is similar for all drivers. First, you install the driver on the host, then you create a network with the new driver, and you attach containers to that network. In some cases, you might need to configure the network by defining network policies for example.\nIn general, custom network drivers provide the flexibility to address specific network challenges in modern applications.\n",
  "wordCount" : "2564",
  "inLanguage": "en",
  "datePublished": "2024-09-19T11:56:50+02:00",
  "dateModified": "2024-09-19T11:56:50+02:00",
  "author":{
    "@type": "Person",
    "name": "Francisco Mendonca"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/docker-networking/dockernetworking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Francisco Mendonca's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Francisco Mendonca&#39;s Blog (Alt + H)">Francisco Mendonca&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Quick Docker Networking Tutorial
    </h1>
    <div class="post-meta"><span title='2024-09-19 11:56:50 +0200 CEST'>September 19, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Francisco Mendonca

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#container-networking" aria-label="Container Networking">Container Networking</a><ul>
                        
                <li>
                    <a href="#messaging-queues" aria-label="Messaging Queues">Messaging Queues</a></li>
                <li>
                    <a href="#step-0-the-program" aria-label="Step 0: The program">Step 0: The program</a></li>
                <li>
                    <a href="#step-1-setup-the-networks" aria-label="Step 1: Setup the networks">Step 1: Setup the networks</a></li>
                <li>
                    <a href="#step-2-deploy-containers-on-each-network" aria-label="Step 2: Deploy containers on each network">Step 2: Deploy containers on each network</a></li>
                <li>
                    <a href="#overlay-networks" aria-label="Overlay Networks">Overlay Networks</a></li></ul>
                </li>
                <li>
                    <a href="#port-publishing-and-external-acess" aria-label="Port Publishing and External Acess">Port Publishing and External Acess</a><ul>
                        
                <li>
                    <a href="#how-port-publishing-works" aria-label="How Port Publishing works?">How Port Publishing works?</a></li></ul>
                </li>
                <li>
                    <a href="#custom-network-drivers" aria-label="Custom Network Drivers">Custom Network Drivers</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This tutorial focuses on two of the several networks Docker has at our disposal, Bridge and Overlay. These two networks allow for the similar uses under different cases.</p>
<p>In Docker, a Bridge Network is the default network. If no network is specified, Docker will assume that, when a container is deployed, it will use the default bridge network. The goal of the bridge network is to allow containers to communicate while remaining isolated from the hosts (the machine where the container are running) networks - and the outside world.</p>
<p><img loading="lazy" src="images/docker-bridge-net.png" alt="Docker Bridge Network"  />
</p>
<p>To communicate, containers connected to a bridge network can communicate using the container&rsquo;s name as hostname. This means that, if we deploy a container by specifying the flag <code>--name</code> or <code>-n</code>, to communicate we can use the name given to the container as the URL, instead of having to use the container&rsquo;s IP address in the network. Docker allows this by internally handling the DNS resolution of these names, to ensure that containers can find each other using known names and not IPs.</p>
<p>The isolation of the network is great and all but sometimes we need to access external networks, or at least, we might need to be able to access the application running inside of the container. For this we can open ports in the network by using the flag <code>-p</code> or <code>--publish</code>, and specifying the target port we want to open <code>HOST:CONTAINER</code>.</p>
<p>Having now understood how Bridge networks work, another problem arises. Bridge networks are limited to a single Docker Host (let&rsquo;s say, our local machine). Therefore, there is no way of connecting containers deployed in serveral machines, as we normally want to do when we use Docker Swarm.</p>
<p>Overlay networks solve this issue by creating a distributed network across multiple hosts (this is done using a combination of tunneling and encryption, but this is a bit hard to explain here). This creates a network where all containers attached to the network are able to communicate, even if they are running in different hosts.</p>
<p>Now, due to their distributed nature, we need to find a new way to communicate. Also, with Docker Swarm, we are deploying services which can have several instances of the same application, thus complicating matters. A service in Docker is an abstraction to define how a group of containers (one or more) should run or behave. It also provides scalling, load balancing, and other things which I&rsquo;ll get to in another post.</p>
<p>So, in an Overlay Network we have two methods to communicate between containers. The first is by using the IP addresses of the container we wish to target (as we already could in a bridge network). The second is to communicate using the <em>service</em> name. Let&rsquo;s supose that we have two services, one called <code>web-server</code> with 3 replicas, and the other called <code>backend-server</code> with 2 replicas. For the <code>web-service</code> to communicate with the <code>backend-service</code> it can use something like <code>http://backend-service:&lt;PORT&gt;</code>, and the rest of the work is done by Swarm, like the load balancing between the instances of the service.</p>
<p>When it comes to communicating between two different bridge networks, Docker doesn’t natively support cross-network communication out of the box because bridge networks are isolated from each other. However, there are ways to enable communication between containers on different bridge networks. The key approaches involve routing traffic between the networks using either:</p>
<ol>
<li>Container Networking: A container connected to both bridge networks.</li>
<li>Port Publishing and External Access: Using the host network as an intermediary.</li>
<li>Custom Network Drivers: Using more advanced configurations like macvlan drivers.</li>
</ol>
<p>Before going through each one of the solutions, let&rsquo;s have a quick chat about why you would want to enable communication between containers on different networks. After all, Docker’s network model is designed with isolation in mind, providing separate namespaces for containers to enhance security, reduce interference, and ensure predictable behavior. So, why break this isolation? Here are a few scenarios where cross-network communication might be necessary:</p>
<ol>
<li>
<p><strong>Microservices Architecture with Legacy Systems</strong>:<br>
Microservices in different networks may need to connect with legacy systems. Cross-network communication enables integration while maintaining isolation.</p>
</li>
<li>
<p><strong>Complex Application Segmentation</strong>:<br>
Segmenting application components into different networks improves organization. Controlled communication ensures they still function together.</p>
</li>
<li>
<p><strong>Enhanced Security and Compliance</strong>:<br>
Isolating sensitive services in secure networks ensures compliance. Controlled interaction allows functionality without compromising security.</p>
</li>
<li>
<p><strong>Multi-Host and Hybrid Deployment</strong>:<br>
Distributed applications across multiple hosts or cloud/on-prem setups may need to connect. Bridging networks enables unified communication across environments.</p>
</li>
<li>
<p><strong>Service Discovery Challenges</strong>:<br>
Different stages or services in isolated networks can complicate discovery. Cross-network communication ensures access to shared resources or services.</p>
</li>
</ol>
<h2 id="container-networking">Container Networking<a hidden class="anchor" aria-hidden="true" href="#container-networking">#</a></h2>
<p>Let&rsquo;s start with our solution by creating two separate bridge networks. We&rsquo;ll place one container on each network and use a third container that is attached to both networks as a communication channel, or &ldquo;gateway.&rdquo; This container will allow the two isolated networks to communicate with each other.</p>
<h3 id="messaging-queues">Messaging Queues<a hidden class="anchor" aria-hidden="true" href="#messaging-queues">#</a></h3>
<p>Messaging queues are communication mechanisms used to exchange data between services, applications, or componenets in a decouples and asynchrounous way. Think of it like a newsletter. You have a producer - someone who publishes the newsletter; a consumer -  the person who receives the newsletter; and a queue - similar to the mailing list, where the newsletter is stored untill all the recipients retrieve and read it. Like with a newsletter, in a messaging queue you can have several consummers which can receive and read the messages at different times. Each subscriber (consumer) consumes the content independently. Unlike traditional newsletters, you can also have several producers to the same queue.</p>
<p>Also, unlike newletters, in a messaging queue system, consumers may acknoledge receipt of messages, and the queue may ensure that messages are delivered exactly once or at least once per consumer.</p>
<p>For this example, we&rsquo;ll use <a href="https://www.rabbitmq.com">RabbitMQ</a>, but there are several commonly used messaging queues such as <a href="https://kafka.apache.org">Apache Kafka</a>, <a href="https://activemq.apache.org">ActiveMQ</a>, <a href="https://mosquitto.org">Mosquitto</a> (similar, not really a messaging queue, but a message broker), and of course solutions by your favorite hyperscaler (AWS, Azure, and the like).</p>
<h3 id="step-0-the-program">Step 0: The program<a hidden class="anchor" aria-hidden="true" href="#step-0-the-program">#</a></h3>
<p>We&rsquo;ll deploy a program that sends and receives messages on a message queue. The idea is to deploy the same program on both networks, and send messages between the networks using the message broker. In this case, the program will do this automatically.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">pika</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set up logging</span>
</span></span><span class="line"><span class="cl"><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set up connection parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">rabbitmq_host</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;RABBITMQ_HOST&#39;</span><span class="p">)</span>  <span class="c1"># RabbitMQ container name </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Check if the RabbitMQ host is set</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">rabbitmq_host</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&#34;RABBITMQ_HOST environment variable is not set&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">connection_params</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="n">rabbitmq_host</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to send messages</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">send_message</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Send a message back to the queue</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">basic_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">routing_key</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">body</span><span class="o">=</span><span class="n">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34; [x] Sent &#39;</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&#39;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to handle received messages and send a response</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">on_message_received</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">received_message</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34; [x] Received &#39;</span><span class="si">{</span><span class="n">received_message</span><span class="si">}</span><span class="s2">&#39;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Create a response message</span>
</span></span><span class="line"><span class="cl">    <span class="n">response_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Response to &#39;</span><span class="si">{</span><span class="n">received_message</span><span class="si">}</span><span class="s2">&#39; from </span><span class="si">{</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Simulate some processing time</span>
</span></span><span class="line"><span class="cl">    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Send the response message</span>
</span></span><span class="line"><span class="cl">    <span class="n">send_message</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">response_message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Function to start the auto-messaging system</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">start_auto_messaging</span><span class="p">(</span><span class="n">start_with_message</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Set up a connection and channel</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">BlockingConnection</span><span class="p">(</span><span class="n">connection_params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Declare a queue</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the system should start by sending a message</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">start_with_message</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">initial_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&#34;Initial message from </span><span class="si">{</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">send_message</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">initial_message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Start consuming and handle each message with the on_message_received function</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">basic_consume</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">on_message_callback</span><span class="o">=</span><span class="n">on_message_received</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">auto_ack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; [*] Waiting for messages. To exit press CTRL+C&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">.</span><span class="n">start_consuming</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Read environment variable to check if the system should start by sending a message</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_with_message</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;START_WITH_MESSAGE&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Start the auto-messaging system</span>
</span></span><span class="line"><span class="cl">    <span class="n">start_auto_messaging</span><span class="p">(</span><span class="n">start_with_message</span><span class="p">)</span>
</span></span></code></pre></div><p>The application is simple: the application receives two environmental variable - one to check if it should start communicating, and the other with the name of the container (in this case RabbitMQ) with the messaging queue. If the application starts communicating, then it starts by sending a message with a random integer. Then, the second container will receive and send back a messgage composed of the message received and a new random integer.</p>
<p>NOTE: There&rsquo;s a slight bug in the app. You&rsquo;ll see that the container who sends the message is also able to read it&rsquo;s own message. This can be avoided by using an app ID and setting it as a property of the message</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">    channel.basic_publish<span class="o">(</span><span class="nv">exchange</span><span class="o">=</span><span class="s1">&#39;&#39;</span>,
</span></span><span class="line"><span class="cl">                          <span class="nv">routing_key</span><span class="o">=</span><span class="s1">&#39;test_queue&#39;</span>,
</span></span><span class="line"><span class="cl">                          <span class="nv">body</span><span class="o">=</span>message,
</span></span><span class="line"><span class="cl">                          <span class="nv">properties</span><span class="o">=</span>pika.BasicProperties<span class="o">(</span>
</span></span><span class="line"><span class="cl">                              <span class="nv">app_id</span><span class="o">=</span>app_id
</span></span><span class="line"><span class="cl">                        <span class="o">))</span>
</span></span></code></pre></div><p>Then you can read the message properties, and select to only process the messages where the app_id isn&rsquo;t the same as the application.
I&rsquo;ve tried to apply this, but there is some timing issues, which leads to the both containers stopping sending messages. When I don&rsquo;t check the app ID, the timing of the messages aligns, as the second container sends two messages in a row, which leads to the first container receiving a message and the ping-pong process of messages starts and continues correctly. If you have a solution for this problem, please don&rsquo;t hesitate to send me a message!</p>
<h3 id="step-1-setup-the-networks">Step 1: Setup the networks<a hidden class="anchor" aria-hidden="true" href="#step-1-setup-the-networks">#</a></h3>
<p>To start, let&rsquo;s create the bridge networks. Remember, you can always do the same thing using Docker Compose.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network create bridge-net-1
</span></span><span class="line"><span class="cl">docker network create bridge-net-2
</span></span></code></pre></div><p>To check if the networks were correctly created, run the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network ls
</span></span></code></pre></div><p>The output should be something like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">code-gen ❯ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID     NAME           DRIVER    SCOPE
</span></span><span class="line"><span class="cl">217ae951f2e2   bridge         bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">ece230c416f2   bridge-net-1   bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">34d8e1e02ae2   bridge-net-2   bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">d068772975fd   host           host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">8bc70472ebe1   none           null      <span class="nb">local</span>
</span></span></code></pre></div><h3 id="step-2-deploy-containers-on-each-network">Step 2: Deploy containers on each network<a hidden class="anchor" aria-hidden="true" href="#step-2-deploy-containers-on-each-network">#</a></h3>
<p>Next, we&rsquo;ll deploy the RabbitMQ container:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -d --name rabbitmq --network bridge-net-1 --network bridge-net-2 rabbitmq
</span></span></code></pre></div><p>Once RabbitMQ is deployed and running, we can deploy the same container in each of the networks:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -d --name app1 --network bridge-net-1 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">true</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span><span class="line"><span class="cl">docker run -d --name app2 --network bridge-net-2 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">false</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span></code></pre></div><p>Once both containers are running, we an check on the logs that the messages are being passed correctly, even if the containers are in seperate networks. The RabbitMQ container, which is attached to both networks, is able to receive messages from both networks and passed them to the opposite network from which the message was sent.</p>
<p><a href="https://github.com/QuietSwami/docker-network-example/blob/main/container-networking/docker-compose.yaml">I&rsquo;ve also wrote a docker-compose file to make the deployment of the application simpler</a>.</p>
<h3 id="overlay-networks">Overlay Networks<a hidden class="anchor" aria-hidden="true" href="#overlay-networks">#</a></h3>
<p>While overlay networks are spread across different hosts, the same process can be used. You can create two overlay networks, attach one container to both, and use that container as a communication channel between the networks. The only difference would be on network creation, where you would have to specify the overlay type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker network create -d overlay overlay-net-1
</span></span><span class="line"><span class="cl">docker network create -d overlay overlay-net-2
</span></span></code></pre></div><p>Now, if you attempt to create these networks you might encounter the following error:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Error response from daemon: This node is not a swarm manager. Use <span class="s2">&#34;docker swarm init&#34;</span> or <span class="s2">&#34;docker swarm join&#34;</span> to connect this node to swarm and try again.
</span></span></code></pre></div><p>Overlay networks are Swarm-specific networks, and can only be created by the manager of the swarm.</p>
<p>To test this locally let&rsquo;s create a Swarm by doing <code>docker swarm init</code>, create the two networks, and lauch the application as a stack of services.
First, let&rsquo;s deploy RabbitMQ as a service:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create --name rabbitmq --network overlay-net-1 --network overlay-net-2 --replicas <span class="m">1</span> rabbitmq:latest
</span></span></code></pre></div><p>Notice that we aren&rsquo;t publishing any ports, as we are not trying to access the RabbitMQ instance from outside of both networks. Without publishing ports, only the containers connected to the network can communicate with the service.</p>
<p>Now, let&rsquo;s deploy our services:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create --name app1 --network overlay-net-1 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">true</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span><span class="line"><span class="cl">docker service create --name app2 --network overlay-net-2 -e <span class="nv">START_WITH_MESSAGE</span><span class="o">=</span><span class="nb">false</span> -e <span class="nv">RABBITMQ_HOST</span><span class="o">=</span>rabbitmq auto_messaging
</span></span></code></pre></div><p>Then, we can check the logs by:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service logs app1
</span></span></code></pre></div><p>You should be able to see messages comming and going from the RabbitMQ between the services deployed in two different overlay networks.</p>
<h2 id="port-publishing-and-external-acess">Port Publishing and External Acess<a hidden class="anchor" aria-hidden="true" href="#port-publishing-and-external-acess">#</a></h2>
<p>In certain cases, we might need to communicate with services running outside of your networks. For this, we need to publish ports for the containers that will communicate. In this case, we are opening these ports to the world—anyone that knows that the port is open can attempt to communicate with our services. This capability is essential for applications that need to be accessed by users or other systems outside of the Docker environment, such as web applications, APIs, or databases.</p>
<h3 id="how-port-publishing-works">How Port Publishing works?<a hidden class="anchor" aria-hidden="true" href="#how-port-publishing-works">#</a></h3>
<p>When you publish a port, you map a port from the container to a port on the host machine. This allows traffic sent to the host&rsquo;s specified port to be routed to the corresponding port on the container. For instance, if you have a web application running in a container on port 80, you can expose it to the outside world by mapping it to a port on the host, such as port 8080.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker service create <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --name my-web-app <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --publish <span class="nv">published</span><span class="o">=</span>8080,target<span class="o">=</span><span class="m">80</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  my-web-app-image
</span></span></code></pre></div><p>While port publishing is a powerful feature, it also introduces security considerations:</p>
<ol>
<li><strong>Open Ports</strong>: When you expose a port, it becomes accessible to anyone who knows the host&rsquo;s IP address and the port number. You should take this into consideration and employ proper security measures.</li>
<li><strong>Secure Protocols</strong>: Always prefer secure protocols, such as HTTPS, when exposing ports.</li>
<li><strong>Rate Limiting</strong>: If you are exposing a port, be sure to implement throttling mechanisms to prevent abuse of your services.</li>
</ol>
<p>Port publishing is a critical part of Docker use, even if you are using a Docker network. There are services that we wish to expose to be able to use them from wherever we are. If you want to know more about how to properly use Swarm, I&rsquo;ve started a series on [Masetering Docker Swarm]({{ &lt; ref &ldquo;Mastering_Docker_Swarm_Pt._1&rdquo;&gt;}}).</p>
<h2 id="custom-network-drivers">Custom Network Drivers<a hidden class="anchor" aria-hidden="true" href="#custom-network-drivers">#</a></h2>
<p>While Bridge and Overlay networks are great out-of-the-box, there are situations where these won&rsquo;t suffice. For this, Docker provides a way to build <em>custom network drivers</em>, which can be customized to suit specific application requirements. This allows for greater flexibility in configuring networks.</p>
<p>The reasons for the use of custom drivers might differ, one use case which seems clear is when you need support for specific, non-standard, protocols (instead of HTTP, something like multicast or specifiying MTU sizes). Another case is when we need to integrate with existing entriprise networks, and better yet, with legacy systems.</p>
<p>Another good reason might be the need for enhanced performace - let&rsquo;s say for high-performance applications, where you need to process real-time data. With a custom network driver, you can tune the network paramaters, which can lead to improvements in data transfer rates or reduced latency.</p>
<p>Also, by creating a custom network driver you can incorporate advanced security features, to further enhanced isolation and encryption of your data.</p>
<p>As you can see <a href="https://github.com/veggiemonk/awesome-docker?tab=readme-ov-file#networking">here</a>, there are already several network drivers developed, which could be used in you next project. These drivers add several tools on top of the default networks, from enhanced logging and monitoring capabilities to support for more complex routing policies.</p>
<p>The procedure to run a custom network driver is similar for all drivers. First, you install the driver on the host, then you create a network with the new driver, and you attach containers to that network. In some cases, you might need to configure the network by defining network policies for example.</p>
<p>In general, custom network drivers provide the flexibility to address specific network challenges in modern applications.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/federation/">
    <span class="title">Next »</span>
    <br>
    <span>Federation</span>
  </a>
</nav>

  </footer>
</article>


    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Francisco Mendonca&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
